<html><head>
<link rel="icon" data-savepage-href="https://web.archive.org/favicon.ico" href=""><script data-savepage-src="//archive.org/includes/analytics.js?v=cf34f82" data-savepage-type="text/javascript" type="text/plain"></script>
<script data-savepage-type="text/javascript" type="text/plain"></script>
<script data-savepage-type="text/javascript" type="text/plain" data-savepage-src="/_static/js/bundle-playback.js?v=MzYkZ0TU" charset="utf-8"></script>
<script data-savepage-type="text/javascript" type="text/plain" data-savepage-src="/_static/js/wombat.js?v=UHAOicsW" charset="utf-8"></script>
<script data-savepage-type="text/javascript" type="text/plain"></script>
<style data-savepage-href="/_static/css/banner-styles.css?v=S1zqJCYt" type="text/css">/*savepage-import-url=record.css*//* style settings for java wayback Save Page Now UI */
  .__wb_overlay {
    filter:alpha(opacity=60); /* IE */
    opacity: 0.6; /* Safari, Opera */
    -moz-opacity:0.6; /* FireFox */  
    opacity: 0.6;
    
    background-color: #000;
    position: fixed;
    width:100%;
    height:100%;
    top: 0px;
    left: 0px;
    padding: 0px !important;
    border: 0px !important;
    margin: 0px !important;
    border-radius: 0px !important;
    z-index: 2147483643 !important;
  }
  
  #__wb_record_overlay_div {
    cursor: wait !important;
  }
  


  .__wb_record_content {
    opacity: 1.0;
    position: fixed;
    top: 50%;
    left: 50%;
    margin: 0px !important;
    padding: 0px !important;

    background-color: #ffffff !important;
    border-radius: 8px;
    z-index: 2147483644 !important;
    box-shadow: 0 0 30px 5px #000;
    -moz-box-shadow: 0 0 30px 5px #000;    
    -webkit-box-shadow: 0 0 30px 5px #000;  
  }
    
  #__wb_record_content_loader {
    cursor: wait !important;
    padding-top: 30px !important;    
    margin-left: -287px !important;
    margin-top: -177px !important;    
    width: 574px !important;
    height: 355px !important;  
  }
  
  #__wb_record_content_done {
    margin-left: -427px !important;
    margin-top: -177px !important;      
    width: 855px !important;
    height: 355px !important;  
  }
  
  .__wb_record_content > * {
    margin: auto !important;
    display: block !important;

    text-align: center !important;
    font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif !important;
  }
  
  .__wb_record_content > wb_h1 {
    font-size: 36px !important;
    color: #222 !important;
    margin: 0px 0px 0px 0px !important;
    padding: 0px !important;
    line-height: 2em;
    font-weight: normal !important;
    width: auto !important;
    height: auto !important;    
  }   
  
  .__wb_record_content > wb_p {
    font-size: 17px !important;
    color: #222 !important;    
    margin: 8px 0px 8px 0px !important;
    padding: 0px !important;
    line-height: 2em;
  }  
  
  .__wb_record_content > #_wb_logo  {
    margin-bottom: 10px !important;
  }
  
  .__wb_record_content > #_wb_spinner {
    margin-top: 30px !important;
    margin-bottom: 30px !important;    
  }
  
  .__wb_record_content > #_wb_curr_url {
    text-decoration: underline !important;
    font-weight: bold !important;
  }
  
  #__wb_record_content_done > #__wb_link {
    font-size: 20px !important;
    border: 1px !important;
    border-color: #aaa !important;
    border-style: solid !important;
    padding: 3px !important;
    text-align: center !important;
    width: 80% !important;
    height: auto !important;
  }
 
  #__wb_record_content_done > #__wb_link:focus {
    outline: 0px !important;
    border-color: #428bca !important;
  }
  
  /* DONATE */
  
  #__wb_record_content_done > #__wb_donate_close {
    font-size: 18px !important;
    width: auto !important;
    float: right;
    display: inline-block;
    margin: 0px !important;
    padding: 8px 8px 0px 0px !important;   
  }
  
  #__wb_donate_close > #__wb_record_done_close {
    cursor: pointer !important;
    display: inline-block;
    vertical-align: bottom !important;
  }
  
  #__wb_record_content_done > #__wb_donate_close a {
    color: #428bca !important;
  } 
  
  #__wb_record_content_done > #__wb_donate_close a:link {
    color: #428bca !important;
    text-decoration: none !important;
    margin-right: 16px !important;
  }
  
  #__wb_record_content_done > #__wb_donate_close a:visited {
    color: #428bca !important;
  } 
  
  #__wb_record_content_done > #__wb_donate_close a:hover {
    color: #00B1F7 !important;
  }

/* Spinner */
#__wb_spinningSquaresG{        
  position: relative;
  width: 240px;
  height: 20px;
  
 
  padding: 0px !important;
  margin: 30px 0px 30px 160px !important;
  border: 0px !important;
  border-radius: 0px !important;
}

.__wb_spinningSquaresG {
   
      
  margin: 0px !important;
  padding: 0px !important;
  border: 0px !important;
  border-radius: 0px !important;
    
position:absolute;
top:0;
background-color:#000000;
width:22px;
height:22px;
-moz-animation-name:bounce_spinningSquaresG;
-moz-animation-duration:1.9s;
-moz-animation-iteration-count:infinite;
-moz-animation-direction:linear;
-moz-transform:scale(.3);
-webkit-animation-name:bounce_spinningSquaresG;
-webkit-animation-duration:1.9s;
-webkit-animation-iteration-count:infinite;
-webkit-animation-direction:linear;
-webkit-transform:scale(.3);
-ms-animation-name:bounce_spinningSquaresG;
-ms-animation-duration:1.9s;
-ms-animation-iteration-count:infinite;
-ms-animation-direction:linear;
-ms-transform:scale(.3);
-o-animation-name:bounce_spinningSquaresG;
-o-animation-duration:1.9s;
-o-animation-iteration-count:infinite;
-o-animation-direction:linear;
-o-transform:scale(.3);
animation-name:bounce_spinningSquaresG;
animation-duration:1.9s;
animation-iteration-count:infinite;
animation-direction:linear;
transform:scale(.3);
}

#__wb_spinningSquaresG_1{
left:0;
-moz-animation-delay:0.76s;
-webkit-animation-delay:0.76s;
-ms-animation-delay:0.76s;
-o-animation-delay:0.76s;
animation-delay:0.76s;
}

#__wb_spinningSquaresG_2{
left:30px;
-moz-animation-delay:0.95s;
-webkit-animation-delay:0.95s;
-ms-animation-delay:0.95s;
-o-animation-delay:0.95s;
animation-delay:0.95s;
}

#__wb_spinningSquaresG_3{
left:60px;
-moz-animation-delay:1.14s;
-webkit-animation-delay:1.14s;
-ms-animation-delay:1.14s;
-o-animation-delay:1.14s;
animation-delay:1.14s;
}

#__wb_spinningSquaresG_4{
left:90px;
-moz-animation-delay:1.33s;
-webkit-animation-delay:1.33s;
-ms-animation-delay:1.33s;
-o-animation-delay:1.33s;
animation-delay:1.33s;
}

#__wb_spinningSquaresG_5{
left:120px;
-moz-animation-delay:1.52s;
-webkit-animation-delay:1.52s;
-ms-animation-delay:1.52s;
-o-animation-delay:1.52s;
animation-delay:1.52s;
}

#__wb_spinningSquaresG_6{
left:150px;
-moz-animation-delay:1.71s;
-webkit-animation-delay:1.71s;
-ms-animation-delay:1.71s;
-o-animation-delay:1.71s;
animation-delay:1.71s;
}

#__wb_spinningSquaresG_7{
left:180px;
-moz-animation-delay:1.9s;
-webkit-animation-delay:1.9s;
-ms-animation-delay:1.9s;
-o-animation-delay:1.9s;
animation-delay:1.9s;
}

#__wb_spinningSquaresG_8{
left:210px;
-moz-animation-delay:2.09s;
-webkit-animation-delay:2.09s;
-ms-animation-delay:2.09s;
-o-animation-delay:2.09s;
animation-delay:2.09s;
}

@-moz-keyframes bounce_spinningSquaresG{
0%{
-moz-transform:scale(1);
background-color:#000000;
}

100%{
-moz-transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

@-webkit-keyframes bounce_spinningSquaresG{
0%{
-webkit-transform:scale(1);
background-color:#000000;
}

100%{
-webkit-transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

@-ms-keyframes bounce_spinningSquaresG{
0%{
-ms-transform:scale(1);
background-color:#000000;
}

100%{
-ms-transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

@-o-keyframes bounce_spinningSquaresG{
0%{
-o-transform:scale(1);
background-color:#000000;
}

100%{
-o-transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

@keyframes bounce_spinningSquaresG{
0%{
transform:scale(1);
background-color:#000000;
}

100%{
transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

 /* for SPN1 */

#wm-ipp-base {
  height:65px;/* initial height just in case js code fails */
  padding:0;
  margin:0;
  border:none;
  background:none transparent;
}
#wm-ipp {
  z-index: 2147483647;
}
#wm-ipp, #wm-ipp * {
  font-family:Lucida Grande, Helvetica, Arial, sans-serif;
  font-size:12px;
  line-height:1.2;
  letter-spacing:0;
  width:auto;
  height:auto;
  max-width:none;
  max-height:none;
  min-width:0 !important;
  min-height:0;
  outline:none;
  float:none;
  text-align:left;
  border:none;
  color: #000;
  text-indent: 0;
  position: initial;
  background: none;
}
#wm-ipp div, #wm-ipp canvas {
  display: block;
}
#wm-ipp div, #wm-ipp tr, #wm-ipp td, #wm-ipp a, #wm-ipp form {
  padding:0;
  margin:0;
  border:none;
  border-radius:0;
  background-color:transparent;
  background-image:none;
  /*z-index:2147483640;*/
  height:auto;
}
#wm-ipp table {
  border:none;
  border-collapse:collapse;
  margin:0;
  padding:0;
  width:auto;
  font-size:inherit;
}
#wm-ipp form input {
  padding:1px !important;
  height:auto;
  display:inline;
  margin:0;
  color: #000;
  background: none #fff;
  border: 1px solid #666;
}
#wm-ipp form input[type=submit] {
  padding:0 8px !important;
  margin:1px 0 1px 5px !important;
  width:auto !important;
  border: 1px solid #000 !important;
  background: #fff !important;
  color: #000 !important;
}
#wm-ipp form input[type=submit]:hover {
  background: #eee !important;
  cursor: pointer !important;
}
#wm-ipp form input[type=submit]:active {
  transform: translateY(1px);
}
#wm-ipp a {
  display: inline;
}    
#wm-ipp a:hover{
  text-decoration:underline;
}
#wm-ipp a.wm-btn:hover {
  text-decoration:none;
  color:#ff0 !important;
}
#wm-ipp a.wm-btn:hover span {
  color:#ff0 !important;
}
#wm-ipp #wm-ipp-inside {
  margin: 0 6px;
  border:5px solid #000;
  border-top:none;
  background-color:rgba(255,255,255,0.9);
  -moz-box-shadow:1px 1px 4px #333;
  -webkit-box-shadow:1px 1px 4px #333;
  box-shadow:1px 1px 4px #333;
  border-radius:0 0 8px 8px;
}
/* selectors are intentionally verbose to ensure priority */
#wm-ipp #wm-logo {
  padding:0 10px;
  vertical-align:middle;
  min-width:100px;
  flex: 0 0 100px;
}
#wm-ipp .c {
  padding-left: 4px;
}
#wm-ipp .c .u {
    margin-top: 4px !important;
}
#wm-ipp .n {
  padding:0 0 0 5px !important;
  vertical-align: bottom;
}
#wm-ipp .n a {
  text-decoration:none;
  color:#33f;
  font-weight:bold;
}
#wm-ipp .n .b {
  padding:0 6px 0 0 !important;
  text-align:right !important;
  overflow:visible;
  white-space:nowrap;
  color:#99a;
  vertical-align:middle;
}
#wm-ipp .n .y .b {
  padding:0 6px 2px 0 !important;
}
#wm-ipp .n .c {
  background:#000;
  color:#ff0;
  font-weight:bold;
  padding:0 !important;
  text-align:center;
}
#wm-ipp.hi .n td.c {
  color:#ec008c;
}
#wm-ipp .n td.f {
  padding:0 0 0 6px !important;
  text-align:left !important;
  overflow:visible;
  white-space:nowrap;
  color:#99a;
  vertical-align:middle;
}
#wm-ipp .n tr.m td {
  text-transform:uppercase;
  white-space:nowrap;
  padding:2px 0;
}
#wm-ipp .c .s {
  padding:0 5px 0 0 !important;
  vertical-align:bottom;
}
#wm-ipp #wm-nav-captures {
  white-space: nowrap;
}
#wm-ipp .c .s a.t {
  color:#33f;
  font-weight:bold;
  line-height: 1.8;
}
#wm-ipp .c .s div.r {
  color: #666;
  font-size:9px;
  white-space:nowrap;
}
#wm-ipp .c .k {
  padding-bottom:1px;
}
#wm-ipp .c .s {
  padding:0 5px 2px 0 !important;
}
#wm-ipp td#displayMonthEl {
  padding: 2px 0 !important;
}
#wm-ipp td#displayYearEl {
  padding: 0 0 2px 0 !important;
}

div#wm-ipp-sparkline {
  position:relative;/* for positioning markers */
  white-space:nowrap;
  background-color:#fff;
  cursor:pointer;
  line-height:0.9;
}
#sparklineImgId, #wm-sparkline-canvas {
  position:relative;
  z-index:9012;
  max-width:none;
}
#wm-ipp-sparkline div.yt {
  position:absolute;
  z-index:9010 !important;
  background-color:#ff0 !important;
  top: 0;
}
#wm-ipp-sparkline div.mt {
  position:absolute;
  z-index:9013 !important;
  background-color:#ec008c !important;
  top: 0;
}  
#wm-ipp .r {
    margin-left: 4px;
}
#wm-ipp .r a {
  color:#33f;
  border:none;
  position:relative;
  background-color:transparent;
  background-repeat:no-repeat !important;
  background-position:100% 100% !important;
  text-decoration: none;
}
#wm-ipp #wm-capinfo {
  /* prevents notice div background from sticking into round corners of
     #wm-ipp-inside */
  border-radius: 0 0 4px 4px;
}
#wm-ipp #wm-capinfo .c-logo {
  display:block;
  float:left;
  margin-right:3px;
  width:90px;
  min-height:90px;
  max-height: 290px;
  border-radius:45px;
  overflow:hidden;
  background-position:50%;
  background-size:auto 90px;
  box-shadow: 0 0 2px 2px rgba(208,208,208,128) inset;
}
#wm-ipp #wm-capinfo .c-logo span {
  display:inline-block;
}
#wm-ipp #wm-capinfo .c-logo img {
  height:90px;
  position:relative;
  left:-50%;
}
#wm-ipp #wm-capinfo .wm-title {
  font-size:130%;
}
#wm-ipp #wm-capinfo a.wm-selector {
  display:inline-block;
  color: #aaa;
  text-decoration:none !important;
  padding: 2px 8px;
}
#wm-ipp #wm-capinfo a.wm-selector.selected {
  background-color:#666;
}
#wm-ipp #wm-capinfo a.wm-selector:hover {
  color: #fff;
}
#wm-ipp #wm-capinfo.notice-only #wm-capinfo-collected-by,
#wm-ipp #wm-capinfo.notice-only #wm-capinfo-timestamps {
    display: none;
}
#wm-ipp #wm-capinfo #wm-capinfo-notice .wm-capinfo-content {
    background-color:#ff0;
    padding:5px;
    font-size:14px;
    text-align:center;
}
#wm-ipp #wm-capinfo #wm-capinfo-notice .wm-capinfo-content * {
    font-size:14px;
    text-align:center;
}
#wm-ipp #wm-expand {
  right: 1px;
  bottom: -1px;
  color: #ffffff;
  background-color: #666 !important;
  padding:0 5px 0 3px !important;
  border-radius: 3px 3px 0 0 !important;
}
#wm-ipp #wm-expand span {
  color: #ffffff;
}
#wm-ipp #wm-expand #wm-expand-icon {
  display: inline-block;
  transition: transform 0.5s;
  transform-origin: 50% 45%;
}
#wm-ipp #wm-expand.wm-open #wm-expand-icon {
  transform: rotate(180deg);
}
#wm-ipp #wmtb {
  text-align:right;
}
#wm-ipp #wmtb #wmtbURL {
  width: calc(100% - 45px);
}
#wm-ipp #wm-graph-anchor {
  border-right:1px solid #ccc;
}
/* time coherence */
html.wb-highlight {
  box-shadow: inset 0 0 0 3px #a50e3a !important;
}    
.wb-highlight {
  outline: 3px solid #a50e3a !important;
}
#wm-ipp-print {
  display:none !important;
}
@media print {
#wm-ipp-base {
  display:none !important;
}
#wm-ipp-print {
  display:block !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
}
@media (max-width:414px) {
    #wm-ipp .xxs {
	display:none !important;
    }
}
@media (min-width:1055px) {
#wm-ipp #wm-graph-anchor {
  display:block !important;
}
}
@media (max-width:1054px) {
#wm-ipp #wm-graph-anchor {
  display:none !important;
}
}
@media (max-width:1163px) {
#wm-logo {
    display:none !important;
}
}

#wm-btns {
    white-space: nowrap;
    margin-top: -2px;
}

#wm-btns #wm-save-snapshot-open {
  margin-right: 7px;
  top: -6px;
}

#wm-btns #wm-sign-in {
  box-sizing: content-box;
  display: none;
  margin-right: 7px;
  top: -8px;

  /*
  round border around sign in button
  */
  border: 2px #000 solid;
  border-radius: 14px;
  padding-right: 2px;
  padding-bottom: 2px;
  width: 11px;
  height: 11px;
}

#wm-btns #wm-sign-in>.iconochive-person {
  font-size: 12.5px;
}

#wm-save-snapshot-open > .iconochive-web {
  color:#000;
  font-size:160%;
}

#wm-ipp #wm-share {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
}

#wm-share > #wm-screenshot {
  display: inline-block;
  margin-right: 3px;
  visibility: hidden;
}

#wm-screenshot > .iconochive-image {
  color:#000;
  font-size:160%;
}

#wm-share > #wm-video {
  display: inline-block;
  margin-right: 3px;
  visibility: hidden;
}

#wm-video > .iconochive-movies {
  color: #000;
  display: inline-block;
  font-size: 150%;
  margin-bottom: 2px;
}

#wm-btns #wm-save-snapshot-in-progress {
  display: none;
  font-size:160%;
  opacity: 0.5;
  position: relative;
  margin-right: 7px;
  top: -5px;
}

#wm-btns #wm-save-snapshot-success {
  display: none;
  color: green;
  position: relative;
  top: -7px;
}

#wm-btns #wm-save-snapshot-fail {
  display: none;
  color: red;
  position: relative;
  top: -7px;
}

.wm-icon-screen-shot {
  background: /*savepage-url=../images/web-screenshot.svg*/ var(--savepage-url-8) no-repeat !important;
  background-size: contain !important;
  width: 22px !important;
  height: 19px !important;

  display: inline-block;
}
#donato {
    /* transition effect is disable so as to simplify height adjustment */
    /*transition: height 0.5s;*/
    height: 0;
    margin: 0;
    padding: 0;
    border-bottom: 1px solid #999 !important;
}
body.wm-modal {
    height: auto !important;
    overflow: hidden !important;
}
#donato #donato-base {
    width: 100%;
    height: 100%;
    /*bottom: 0;*/
    margin: 0;
    padding: 0;
    position: absolute;
    z-index: 2147483639;
}
body.wm-modal #donato #donato-base {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 2147483640;
}

.wb-autocomplete-suggestions {
    font-family: Lucida Grande, Helvetica, Arial, sans-serif;
    font-size: 12px;
    text-align: left;
    cursor: default;
    border: 1px solid #ccc;
    border-top: 0;
    background: #fff;
    box-shadow: -1px 1px 3px rgba(0,0,0,.1);
    position: absolute;
    display: none;
    z-index: 2147483647;
    max-height: 254px;
    overflow: hidden;
    overflow-y: auto;
    box-sizing: border-box;
}
.wb-autocomplete-suggestion {
    position: relative;
    padding: 0 .6em;
    line-height: 23px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 1.02em;
    color: #333;
}
.wb-autocomplete-suggestion b {
    font-weight: bold;
}
.wb-autocomplete-suggestion.selected {
    background: #f0f0f0;
}
</style>
<style data-savepage-href="/_static/css/iconochive.css?v=qtvMKcIJ" type="text/css">@font-face{font-family:'Iconochive-Regular';src:/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.eot?-ccsheb*/url();src:/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.eot?#iefix-ccsheb*/url() format('embedded-opentype'),/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.woff?-ccsheb*/url(data:application/octet-stream;base64,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) format('woff'),/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.ttf?-ccsheb*/url() format('truetype'),/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.svg?-ccsheb#Iconochive-Regular*/url() format('svg');font-weight:normal;font-style:normal}
[class^="iconochive-"],[class*=" iconochive-"]{font-family:'Iconochive-Regular'!important;speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
.iconochive-Uplevel:before{content:"\21b5"}
.iconochive-exit:before{content:"\1f6a3"}
.iconochive-beta:before{content:"\3b2"}
.iconochive-logo:before{content:"\1f3db"}
.iconochive-audio:before{content:"\1f568"}
.iconochive-movies:before{content:"\1f39e"}
.iconochive-software:before{content:"\1f4be"}
.iconochive-texts:before{content:"\1f56e"}
.iconochive-etree:before{content:"\1f3a4"}
.iconochive-image:before{content:"\1f5bc"}
.iconochive-web:before{content:"\1f5d4"}
.iconochive-collection:before{content:"\2211"}
.iconochive-folder:before{content:"\1f4c2"}
.iconochive-data:before{content:"\1f5c3"}
.iconochive-tv:before{content:"\1f4fa"}
.iconochive-article:before{content:"\1f5cf"}
.iconochive-question:before{content:"\2370"}
.iconochive-question-dark:before{content:"\3f"}
.iconochive-info:before{content:"\69"}
.iconochive-info-small:before{content:"\24d8"}
.iconochive-comment:before{content:"\1f5e9"}
.iconochive-comments:before{content:"\1f5ea"}
.iconochive-person:before{content:"\1f464"}
.iconochive-people:before{content:"\1f465"}
.iconochive-eye:before{content:"\1f441"}
.iconochive-rss:before{content:"\221e"}
.iconochive-time:before{content:"\1f551"}
.iconochive-quote:before{content:"\275d"}
.iconochive-disc:before{content:"\1f4bf"}
.iconochive-tv-commercial:before{content:"\1f4b0"}
.iconochive-search:before{content:"\1f50d"}
.iconochive-search-star:before{content:"\273d"}
.iconochive-tiles:before{content:"\229e"}
.iconochive-list:before{content:"\21f6"}
.iconochive-list-bulleted:before{content:"\2317"}
.iconochive-latest:before{content:"\2208"}
.iconochive-left:before{content:"\2c2"}
.iconochive-right:before{content:"\2c3"}
.iconochive-left-solid:before{content:"\25c2"}
.iconochive-right-solid:before{content:"\25b8"}
.iconochive-up-solid:before{content:"\25b4"}
.iconochive-down-solid:before{content:"\25be"}
.iconochive-dot:before{content:"\23e4"}
.iconochive-dots:before{content:"\25a6"}
.iconochive-columns:before{content:"\25af"}
.iconochive-sort:before{content:"\21d5"}
.iconochive-atoz:before{content:"\1f524"}
.iconochive-ztoa:before{content:"\1f525"}
.iconochive-upload:before{content:"\1f4e4"}
.iconochive-download:before{content:"\1f4e5"}
.iconochive-favorite:before{content:"\2605"}
.iconochive-heart:before{content:"\2665"}
.iconochive-play:before{content:"\25b6"}
.iconochive-play-framed:before{content:"\1f3ac"}
.iconochive-fullscreen:before{content:"\26f6"}
.iconochive-mute:before{content:"\1f507"}
.iconochive-unmute:before{content:"\1f50a"}
.iconochive-share:before{content:"\1f381"}
.iconochive-edit:before{content:"\270e"}
.iconochive-reedit:before{content:"\2710"}
.iconochive-gear:before{content:"\2699"}
.iconochive-remove-circle:before{content:"\274e"}
.iconochive-plus-circle:before{content:"\1f5d6"}
.iconochive-minus-circle:before{content:"\1f5d5"}
.iconochive-x:before{content:"\1f5d9"}
.iconochive-fork:before{content:"\22d4"}
.iconochive-trash:before{content:"\1f5d1"}
.iconochive-warning:before{content:"\26a0"}
.iconochive-flash:before{content:"\1f5f2"}
.iconochive-world:before{content:"\1f5fa"}
.iconochive-lock:before{content:"\1f512"}
.iconochive-unlock:before{content:"\1f513"}
.iconochive-twitter:before{content:"\1f426"}
.iconochive-facebook:before{content:"\66"}
.iconochive-googleplus:before{content:"\67"}
.iconochive-reddit:before{content:"\1f47d"}
.iconochive-tumblr:before{content:"\54"}
.iconochive-pinterest:before{content:"\1d4df"}
.iconochive-popcorn:before{content:"\1f4a5"}
.iconochive-email:before{content:"\1f4e7"}
.iconochive-embed:before{content:"\1f517"}
.iconochive-gamepad:before{content:"\1f579"}
.iconochive-Zoom_In:before{content:"\2b"}
.iconochive-Zoom_Out:before{content:"\2d"}
.iconochive-RSS:before{content:"\1f4e8"}
.iconochive-Light_Bulb:before{content:"\1f4a1"}
.iconochive-Add:before{content:"\2295"}
.iconochive-Tab_Activity:before{content:"\2318"}
.iconochive-Forward:before{content:"\23e9"}
.iconochive-Backward:before{content:"\23ea"}
.iconochive-No_Audio:before{content:"\1f508"}
.iconochive-Pause:before{content:"\23f8"}
.iconochive-No_Favorite:before{content:"\2606"}
.iconochive-Unike:before{content:"\2661"}
.iconochive-Song:before{content:"\266b"}
.iconochive-No_Flag:before{content:"\2690"}
.iconochive-Flag:before{content:"\2691"}
.iconochive-Done:before{content:"\2713"}
.iconochive-Check:before{content:"\2714"}
.iconochive-Refresh:before{content:"\27f3"}
.iconochive-Headphones:before{content:"\1f3a7"}
.iconochive-Chart:before{content:"\1f4c8"}
.iconochive-Bookmark:before{content:"\1f4d1"}
.iconochive-Documents:before{content:"\1f4da"}
.iconochive-Newspaper:before{content:"\1f4f0"}
.iconochive-Podcast:before{content:"\1f4f6"}
.iconochive-Radio:before{content:"\1f4fb"}
.iconochive-Cassette:before{content:"\1f4fc"}
.iconochive-Shuffle:before{content:"\1f500"}
.iconochive-Loop:before{content:"\1f501"}
.iconochive-Low_Audio:before{content:"\1f509"}
.iconochive-First:before{content:"\1f396"}
.iconochive-Invisible:before{content:"\1f576"}
.iconochive-Computer:before{content:"\1f5b3"}
</style>
<!-- End Wayback Rewrite JS Include -->
<title>Unix Socket FAQ</title>
<style id="savepage-cssvariables">
  :root {
    --savepage-url-8: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjIwIiB2aWV3Qm94PSIwIDAgMjQgMjAiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Im0wIDBoMjR2MjBoLTI0eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Im0xOC41NzIxNTI1IDE1Ljg3MzEzMTRoLTIuMjEzNzUxdi0yLjE2MTAwNDNoMi4yMTM3NTF6bS0zLjI2NDc3MDMgMGgtMi4yMTQ5MDI2di0yLjE2MTAwNDNoMi4yMTQ5MDI2em0zLjEyNjU2OTItMTEuNTY5OTY0Mjl2NS44MjU0MDU5OSAxLjUyNTI3OTNoLTE2Ljg2NjI5MDQ1di0xLjUyNTI3OTMtNS44MjU0MDU5OXptLTYuNDc5MDk3MSAxMS41Njk5NjQyOWgtMTAuMzU0NDg1NzZ2LTIuMTE2MDg4OWgxMC4zNTQ0ODU3NnptLTExLjk1NDg1NDMtMTMuMDczMTMxNHY2Ljc0NDIxMjgzIDcuNzIyNDQ2MTdoMjB2LTcuNzIyNDQ2MTctNi43NDQyMTI4M3oiIGZpbGw9IiMzMzMiIGZpbGwtcnVsZT0ibm9uemVybyIgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCAxOC4wNjcpIi8+PHJlY3QgZmlsbD0iIzMzMyIgaGVpZ2h0PSIxMCIgcng9IjEiIHN0cm9rZT0iIzMzMyIgd2lkdGg9IjE0LjkwNiIgeD0iOCIgeT0iOSIvPjxjaXJjbGUgY3g9IjE1LjQ1MyIgY3k9IjE0IiBmaWxsPSIjZmZmIiByPSIzLjQ5MSIvPjxjaXJjbGUgY3g9IjE1LjQ1MyIgY3k9IjE0IiBmaWxsPSIjMzMzIiByPSIxLjYwNCIvPjwvZz48L3N2Zz4=);
    --savepage-url-9: url(data:image/jpeg;base64,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);
    --savepage-url-10: url(data:image/jpeg;base64,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);
  }
</style>
<script id="savepage-shadowloader" type="text/javascript">
  "use strict";
  window.addEventListener("DOMContentLoaded",
  function(event) {
    savepage_ShadowLoader(5);
  },false);
  function savepage_ShadowLoader(c){createShadowDOMs(0,document.documentElement);function createShadowDOMs(a,b){var i;if(b.localName=="iframe"||b.localName=="frame"){if(a<c){try{if(b.contentDocument.documentElement!=null){createShadowDOMs(a+1,b.contentDocument.documentElement)}}catch(e){}}}else{if(b.children.length>=1&&b.children[0].localName=="template"&&b.children[0].hasAttribute("data-savepage-shadowroot")){b.attachShadow({mode:"open"}).appendChild(b.children[0].content);b.removeChild(b.children[0]);for(i=0;i<b.shadowRoot.children.length;i++)if(b.shadowRoot.children[i]!=null)createShadowDOMs(a,b.shadowRoot.children[i])}for(i=0;i<b.children.length;i++)if(b.children[i]!=null)createShadowDOMs(a,b.children[i])}}}
</script>
<meta name="savepage-url" content="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/sockets-faq.html">
<meta name="savepage-title" content="Unix Socket FAQ">
<meta name="savepage-pubdate" content="Unknown">
<meta name="savepage-from" content="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/sockets-faq.html">
<meta name="savepage-date" content="Wed Jan 04 2023 20:00:03 GMT+0300 (Москва, стандартное время)">
<meta name="savepage-state" content="Standard Items; Retain cross-origin frames; Merge CSS images; Remove unsaved URLs; Load lazy images in existing content; Max frame depth = 5; Max resource size = 50MB; Max resource time = 10s;">
<meta name="savepage-version" content="28.3">
<meta name="savepage-comments" content="">
  </head>

	<body vlink="007f00" text="000000" link="007f7f" bgcolor="ffffff"><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
</style>
<script data-savepage-type="" type="text/plain"></script>
<div id="wm-ipp-base" style="display: block; direction: ltr; height: 1px;" lang="en"><template data-savepage-shadowroot=""><div id="wm-ipp" style="position:fixed;left:0;top:0;right:0;">
<div id="donato" style="position:relative;width:100%;">
  <div id="donato-base">
    <iframe id="donato-if" data-savepage-src="https://archive.org/includes/donate.php?as_page=1&platform=wb&referer=https%3A//web.archive.org/web/20090418145854/http%3A//www.sbin.org/doc/unix-faq/sockets-faq.html" src="" scrolling="no" style="width:100%; height:100%" frameborder="0"></iframe>
  </div>
</div><div id="wm-ipp-inside" style="display: none;">
  <div id="wm-toolbar" style="position:relative;display:flex;flex-flow:row nowrap;justify-content:space-between;">
    <div id="wm-logo" style="/*width:110px;*/padding-top:12px;">
      <a data-savepage-href="/web/" href="https://web.archive.org/web/" title="Wayback Machine home page"><img data-savepage-currentsrc="https://web.archive.org/_static/images/toolbar/wayback-toolbar-logo-100.png" data-savepage-src="/_static/images/toolbar/wayback-toolbar-logo-200.png" src="data:image/png;base64,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" data-savepage-srcset="/_static/images/toolbar/wayback-toolbar-logo-100.png, /_static/images/toolbar/wayback-toolbar-logo-150.png 1.5x, /_static/images/toolbar/wayback-toolbar-logo-200.png 2x" srcset="" alt="Wayback Machine" style="width:100px" border="0"></a>
    </div>
    <div class="c" style="display:flex;flex-flow:column nowrap;justify-content:space-between;flex:1;">
      <form class="u" style="display:flex;flex-direction:row;flex-wrap:nowrap;" target="_top" method="get" action="/web/submit" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.sbin.org/doc/unix-faq/sockets-faq.html" onfocus="this.focus();this.select();" style="flex:1;" autocomplete="off"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20090418145854"><input type="submit" value="Go">
      </form>
      <div style="display:flex;flex-flow:row nowrap;align-items:flex-end;">
		<div class="s" id="wm-nav-captures" style="flex:1;"><a class="t" data-savepage-href="/web/*/http://www.sbin.org/doc/unix-faq/sockets-faq.html" href="https://web.archive.org/web/*/http://www.sbin.org/doc/unix-faq/sockets-faq.html" title="See a list of every capture for this URL">30 captures</a><div class="r" title="Timespan for captures of this URL">12 May 2003 - 9 Dec 2017</div></div>
	<div class="k">
	  <a href="" id="wm-graph-anchor">
	    <div id="wm-ipp-sparkline" title="Explore captures for this URL" style="position: relative">
	      <canvas style="/*savepage-canvas-image*/ background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArwAAAAbCAYAAACePFw8AAAFBUlEQVR4Xu2cwXXbMBAFpRpySgUuwO4mLaU0q4D0kB4cS7GciBbJ2QUBgtTkksuSAOYvoBGeno+vr69vLy8vx0PFf47B4cpKVpwAr7SvYqyen3/xBxKVp9PTwXOXgbN3Gadz1QSrt4+3FH/Wm8ciefCXzFSaB0d5FBaHJStZcQK80r7qj5XCyzKxdxmnGRnlL8nLj8I7YGfv8rbbCyuFl2c+9e058Jbp0r00luvgLSGr/lgpvCwTe5dxUng5pw5YxSY7Ue3+4ChbsFJ4eR4Kr6wCBHhpi43uGLE8FF7Gy75inDqQOG94veHlzbpTVgpvoAU83DksWcmKE+CVrfpK4WWZtMrD3zsX56Hw7lTi3INsb5yrFF7OyhteWQUI8FIPrP5YKbwsE3uXcfKGl3PqgFVsshPV7g+OsgUrhZfnofDKKkCAl7bY6I4Ry0PhZbzsK8apA4nzhtcbXt6sO2Wl8AZawMOdw5KVrDgBXtmqrxRelkmrPPxJQ3EeCu9OJc49yPbGuUrh5ay84ZVVgAAv9cDqj5XCyzKxdxknb3g5pw5YxSY7Ue3+4ChbsFJ4eR4Kr6wCBHhpxY3+eatTcYzPhS4wxuwt1AJjzAZzHkPhncV0KWiVhze8xXnM7i02gplTTu6PCKk2faXwBjLxcOewZNUFK4WXx3Aj7govA+c+Z5w6kB+FdxCVvbuZ3uUTnalUeAMo3SAclqy6YKXw8hgU3iQrb18ZuJXPRIVX4WWNeqdq5d5Nz3v4oMIbQLmX0F0HD33jrBReHrXCm2Sl8DJwK58lCq/CyxpV4U1zujy48kYvm/x/T7sOjlJWXbBSeHkMCm+SlcLLwK18Jiq8Ci9rVIU3zUnhDaJb+VAMzna83HVwlBVZKbw8BoU3yUrhZeAq7vOb3h3JQ+FVeFmjKrxpTgpvEN3Kh2JwtgrvEsAqZq7wJgLyrzRwaBV7l0gcn+hM5QOsQ+FVeNP7ZS/7w9/wBlpgL6G7Dh76xlkpvDxqb3iTrLzhZeBWPksUXoWXNao3vGlO3vAG0a18KAZn6w3vEsAqZq7wJgLyhpdDq9i73vDyGAgrhVfhTXTU30f2ss+94Q20wF5Cf8B1XA/7a9rHQeyjHwYbZ9VSeEs+UIf5DHflNS8yxljN2BjDXrgc7vf+Du/x+OMyr9+Hn5f/v719D5wet6Wn09MB3oySNd+dR4Xe/bKPJsZIz3u4mDtjLPbu61gVWH3JJDFGeJ0gj7EzEPcyWEd43vQ8xpMEhWAd4C3TJY7BEbZgpfDyPHbzLadFY3U2hsL7LnFQsAI74qa05ENO4R2nnuZaYQ8qvNndkbslC2ev8PKAKuyPJb7k8AV8VLoOjkzh5awU3u2yUngVXm94A/t3pFThLWCYEBOFt4D33KOJPOZeqfCGCf17oEUeCm8goBaBOAYPJMBK4VV4FV6+tcYqFd4ChoHz6jqKwlvAe+7RRB5zr1R4w4QU3hQym5dje0BWCq/Cq/DyI0LhLWe1hPwovBVyuL7yAT8H0zT3wsob3kAL7CX0B1yHwqvwKryBs86fNJTDGr4hce4qvMvH8PnGRB7h2TgGR9aClcLL8/A3vNtlpfAqvApvYP8qvOWwFN7Dl7+AAqmGRR++96ashWA5Bk+mBSuFl+eh8G6XlcKr8Cq8gf2r8JbDUngV3hYS5xh8ryq8nJXCu11WCq/Cq/AG9q/CWw5L4VV4lVG+j1qw+gP3exjQ3XmL3gAAAABJRU5ErkJggg==) !important; background-attachment: scroll !important; background-blend-mode: normal !important; background-clip: content-box !important; background-color: transparent !important; background-origin: content-box !important; background-position: center center !important; background-repeat: no-repeat !important; background-size: 100% 100% !important;" id="wm-sparkline-canvas" border="0" width="700" height="27"></canvas>
	    <div class="yt" style="display: none; width: 25px; height: 27px;"></div><div class="mt" style="display: none; width: 2px; height: 27px;"></div></div>
	  </a>
	</div>
      </div>
    </div>
    <div class="n">
      <table>
	<tbody>
	  <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
	  <tr class="m">
	    <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20090310232709/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html" title="10 Mar 2009"><strong>Mar</strong></a></td>
	    <td class="c" id="displayMonthEl" title="You are here: 14:58:54 Apr 18, 2009">APR</td>
	    <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20100513012222/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html" title="13 May 2010"><strong>May</strong></a></td>
	  </tr>
	  <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
	  <tr class="d">
	    <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20090310232709/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html" title="23:27:09 Mar 10, 2009"><img data-savepage-currentsrc="https://web.archive.org/_static/images/toolbar/wm_tb_prv_on.png" data-savepage-src="/_static/images/toolbar/wm_tb_prv_on.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAYAAAAmlE46AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMZJREFUeNqU07EKQWEUwHEuSSaLkicgg3TZzCySvIKk2GVgJZmsBg9g8QK8gcHoASwGNoMS/l+db6Au3zn1W279b+fe796w779Cyimi7ymCFBbYox51CGLoYIS0XHv+C2uYynofExRmJWgG3fE7TGKMHuK/VrFhRJ7DRBmXN2XCBibIa87Ek5US2sM04Ro5DHDRhGbumMu6SzxcQztndFHGVhPaOaCKFo6a0Iz5+jcoYYira2jnhhkKWNlO83ec0EYFu7cAAwCVABzGI3/GxAAAAABJRU5ErkJggg==" alt="Previous capture" width="14" height="16" border="0"></a></td>
	    <td class="c" id="displayDayEl" style="width:34px;font-size:22px;white-space:nowrap;" title="You are here: 14:58:54 Apr 18, 2009">18</td>
	    <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20100513012222/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html" title="01:22:22 May 13, 2010"><img data-savepage-currentsrc="https://web.archive.org/_static/images/toolbar/wm_tb_nxt_on.png" data-savepage-src="/_static/images/toolbar/wm_tb_nxt_on.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAYAAAAmlE46AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMhJREFUeNqU0s8KAUEcwPHBJjm5KHkCV+07cJHkKZRyUK6cKYeVPxd5BVcHjspB+VPKA7g4cHNQwndqp/awMb9ffdra+jazMxtx3c9UKTXCTgkmihK28JCWhG//2cARdcRtwuBkMMQGRUloJo8F5shJQjMV/9D6SElCPQk0cUINMdvQTBYTHFCWhGaSeheOILihiwGeNuELM7RxNS//hUu0sLe9jjOqKIRFYSve0fP/nsevrTiBVfV3dHCxOSkdrjDGWnInXwEGAM40IjLd/vWIAAAAAElFTkSuQmCC" alt="Next capture" width="14" height="16" border="0"></a></td>
	  </tr>
	  <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
	  <tr class="y">
	    <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20080415093655/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html" title="15 Apr 2008"><strong>2008</strong></a></td>
	    <td class="c" id="displayYearEl" title="You are here: 14:58:54 Apr 18, 2009">2009</td>
	    <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20100513012222/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html" title="13 May 2010"><strong>2010</strong></a></td>
	  </tr>
	</tbody>
      </table>
    </div>
    <div class="r" style="display:flex;flex-flow:column nowrap;align-items:flex-end;justify-content:space-between;">
      <div id="wm-btns" style="text-align:right;height:23px;">
        	<span class="xxs">
          <div id="wm-save-snapshot-success">success</div>
          <div id="wm-save-snapshot-fail">fail</div>
          <a id="wm-save-snapshot-open" href="#" title="Share via My Web Archive" style="display: none;">
            <span class="iconochive-web"></span>
          </a>
          <a href="https://archive.org/account/login.php" title="Sign In" id="wm-sign-in" style="display: inline-block;">
            <span class="iconochive-person"></span>
          </a>
          <span id="wm-save-snapshot-in-progress" class="iconochive-web" style="display: none;"></span>
	</span>
        	<a class="xxs" href="http://faq.web.archive.org/" title="Get some help using the Wayback Machine" style="top:-6px;"><span class="iconochive-question" style="color:rgb(87,186,244);font-size:160%;"></span></a>
	<a id="wm-tb-close" href="#close" style="top:-2px;" title="Close the toolbar"><span class="iconochive-remove-circle" style="color:#888888;font-size:240%;"></span></a>
      </div>
      <div id="wm-share" class="xxs">
        <a data-savepage-href="/web/20090418145854/http://web.archive.org/screenshot/http://www.sbin.org/doc/unix-faq/sockets-faq.html" href="https://web.archive.org/web/20090418145854/http://web.archive.org/screenshot/http://www.sbin.org/doc/unix-faq/sockets-faq.html" id="wm-screenshot" title="screenshot" style="visibility: hidden;">
          <span class="wm-icon-screen-shot"></span>
        </a>
        <a href="#" id="wm-video" title="video">
          <span class="iconochive-movies"></span>
        </a>
	<a id="wm-share-facebook" href="#" data-url="https://web.archive.org/web/20090418145854/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html" title="Share on Facebook" style="margin-right:5px;" target="_blank"><span class="iconochive-facebook" style="color:#3b5998;font-size:160%;"></span></a>
	<a id="wm-share-twitter" href="#" data-url="https://web.archive.org/web/20090418145854/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html" title="Share on Twitter" style="margin-right:5px;" target="_blank"><span class="iconochive-twitter" style="color:#1dcaff;font-size:160%;"></span></a>
      </div>
      <div style="padding-right:2px;text-align:right;white-space:nowrap;">
	<a id="wm-expand" class="wm-btn wm-closed" href="#expand" onclick="__wm.ex(event);return false;"><span id="wm-expand-icon" class="iconochive-down-solid"></span> <span class="xxs" style="font-size:80%;">About this capture</span></a>
      </div>
    </div>
  </div>
    <div id="wm-capinfo" style="border-top:1px solid #777;display:none; overflow: hidden">
                    <div id="wm-capinfo-collected-by">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center">COLLECTED BY</div>
    <div style="padding:3px;position:relative" id="wm-collected-by-content">
            <div style="display:inline-block;vertical-align:top;width:50%;">
			<span class="c-logo" style="background-image:/*savepage-url=https://archive.org/services/img/alexacrawls*/var(--savepage-url-9);"></span>
		Organization: <a style="color:#33f;" href="https://archive.org/details/alexacrawls" target="_new"><span class="wm-title">Alexa Crawls</span></a>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  Starting in 1996, <a href="http://www.alexa.com/">Alexa Internet</a> has been donating their crawl data to the Internet Archive.  Flowing in every day, these data are added to the <a href="http://web.archive.org/">Wayback Machine</a> after an embargo period.
	</div>
	      </div>
      <div style="display:inline-block;vertical-align:top;width:49%;">
			<span class="c-logo" style="background-image:/*savepage-url=https://archive.org/services/img/alexa_web_2009*/var(--savepage-url-10)"></span>
		<div>Collection: <a style="color:#33f;" href="https://archive.org/details/alexa_web_2009" target="_new"><span class="wm-title">alexa_web_2009</span></a></div>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  this data is currently not publicly accessible.
	</div>
	      </div>
    </div>
    </div>
    <div id="wm-capinfo-timestamps">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center" title="Timestamps for the elements of this page">TIMESTAMPS</div>
    <div>
      <div id="wm-capresources" style="margin:0 5px 5px 5px;max-height:250px;overflow-y:scroll !important"></div>
      <div id="wm-capresources-loading" style="text-align:left;margin:0 20px 5px 5px;display:none"><img data-savepage-currentsrc="https://web.archive.org/_static/images/loading.gif" data-savepage-src="/_static/images/loading.gif" src="data:image/gif;base64,R0lGODlhFAAUAOMIAAAAABoaGjMzM0xMTGZmZoCAgJmZmbKysv///////////////////////////////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQBCgAIACwAAAAAFAAUAAAEUxDJSau9CADMteZTEEjehhzHJYqkiaLWOlZvGs8WDO6UIPAGw8TnAwWDEuKPcxQml0YnjzcYYAqFS7VqwWItWyuCQJB4s2AxmWxGg9bl6YQtl0cAACH5BAEKAA8ALAAAAAAUABQAAART8MlJq70vBMy15pMgSN72AMAliqSJotY6Vm8azxYM7tQw8IfDxOcDBYMS4o9zFCaXRiePRyBgDIZLtWrBYi1b66NQkHizYDGZbEaD1uXphC2XRwAAIfkEAQoADwAsAAAAABQAFAAABFPwyUmrvU8IzLXm0zBI3vYEwSWKpImi1jpWbxrPFgzuFEHwAMDE5wMFgxLij3MUJpdGJ49XKGAOh0u1asFiLVvrw2CQeLNgMZlsRoPW5emELZdHAAAh+QQBCgAPACwAAAAAFAAUAAAEU/DJSau9bwzMteYTQUje9gjCJYqkiaLWOlZvGs8WDO5UUfCBwMTnAwWDEuKPcxQml0Ynj2cwYACAS7VqwWItW+vjcJB4s2AxmWxGg9bl6YQtl0cAACH5BAEKAA8ALAAAAAAUABQAAART8MlJq72PEMy15lNRSN72DMMliqSJotY6Vm8azxYM7pRh8ALBxOcDBYMS4o9zFCaXRiePdzhgAoFLtWrBYi1b6wMAkHizYDGZbEaD1uXphC2XRwAAIfkEAQoADwAsAAAAABQAFAAABFPwyUmrva8UzLXmk2FI3vYQxCWKpImi1jpWbxrPFgzu1HHwg8HE5wMFgxLij3MUJpdGJ48HAGAEgku1asFiLVvrIxCQeLNgMZlsRoPW5emELZdHAAAh+QQBCgAPACwAAAAAFAAUAAAEU/DJSau9zxjMtebTcUje9hTFJYqkiaLWOlZvGs8WDO4UAPAEwsTnAwWDEuKPcxQml0YnjxcIYAaDS7VqwWItW+tDIJB4s2AxmWxGg9bl6YQtl0cAACH5BAEKAA8ALAAAAAAUABQAAART8MlJq73vHMy15hMASN72GMYliqSJotY6Vm8azxYM7lQQ8IXCxOcDBYMS4o9zFCaXRiePJxBgCIRLtWrBYi1b62MwkHizYDGZbEaD1uXphC2XRwAAOw==" alt="loading"></div>
    </div>
    </div>
  </div></div></div><style data-savepage-href="/_static/css/banner-styles.css?v=S1zqJCYt" type="text/css">/*savepage-import-url=record.css*//* style settings for java wayback Save Page Now UI */
  .__wb_overlay {
    filter:alpha(opacity=60); /* IE */
    opacity: 0.6; /* Safari, Opera */
    -moz-opacity:0.6; /* FireFox */  
    opacity: 0.6;
    
    background-color: #000;
    position: fixed;
    width:100%;
    height:100%;
    top: 0px;
    left: 0px;
    padding: 0px !important;
    border: 0px !important;
    margin: 0px !important;
    border-radius: 0px !important;
    z-index: 2147483643 !important;
  }
  
  #__wb_record_overlay_div {
    cursor: wait !important;
  }
  


  .__wb_record_content {
    opacity: 1.0;
    position: fixed;
    top: 50%;
    left: 50%;
    margin: 0px !important;
    padding: 0px !important;

    background-color: #ffffff !important;
    border-radius: 8px;
    z-index: 2147483644 !important;
    box-shadow: 0 0 30px 5px #000;
    -moz-box-shadow: 0 0 30px 5px #000;    
    -webkit-box-shadow: 0 0 30px 5px #000;  
  }
    
  #__wb_record_content_loader {
    cursor: wait !important;
    padding-top: 30px !important;    
    margin-left: -287px !important;
    margin-top: -177px !important;    
    width: 574px !important;
    height: 355px !important;  
  }
  
  #__wb_record_content_done {
    margin-left: -427px !important;
    margin-top: -177px !important;      
    width: 855px !important;
    height: 355px !important;  
  }
  
  .__wb_record_content > * {
    margin: auto !important;
    display: block !important;

    text-align: center !important;
    font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif !important;
  }
  
  .__wb_record_content > wb_h1 {
    font-size: 36px !important;
    color: #222 !important;
    margin: 0px 0px 0px 0px !important;
    padding: 0px !important;
    line-height: 2em;
    font-weight: normal !important;
    width: auto !important;
    height: auto !important;    
  }   
  
  .__wb_record_content > wb_p {
    font-size: 17px !important;
    color: #222 !important;    
    margin: 8px 0px 8px 0px !important;
    padding: 0px !important;
    line-height: 2em;
  }  
  
  .__wb_record_content > #_wb_logo  {
    margin-bottom: 10px !important;
  }
  
  .__wb_record_content > #_wb_spinner {
    margin-top: 30px !important;
    margin-bottom: 30px !important;    
  }
  
  .__wb_record_content > #_wb_curr_url {
    text-decoration: underline !important;
    font-weight: bold !important;
  }
  
  #__wb_record_content_done > #__wb_link {
    font-size: 20px !important;
    border: 1px !important;
    border-color: #aaa !important;
    border-style: solid !important;
    padding: 3px !important;
    text-align: center !important;
    width: 80% !important;
    height: auto !important;
  }
 
  #__wb_record_content_done > #__wb_link:focus {
    outline: 0px !important;
    border-color: #428bca !important;
  }
  
  /* DONATE */
  
  #__wb_record_content_done > #__wb_donate_close {
    font-size: 18px !important;
    width: auto !important;
    float: right;
    display: inline-block;
    margin: 0px !important;
    padding: 8px 8px 0px 0px !important;   
  }
  
  #__wb_donate_close > #__wb_record_done_close {
    cursor: pointer !important;
    display: inline-block;
    vertical-align: bottom !important;
  }
  
  #__wb_record_content_done > #__wb_donate_close a {
    color: #428bca !important;
  } 
  
  #__wb_record_content_done > #__wb_donate_close a:link {
    color: #428bca !important;
    text-decoration: none !important;
    margin-right: 16px !important;
  }
  
  #__wb_record_content_done > #__wb_donate_close a:visited {
    color: #428bca !important;
  } 
  
  #__wb_record_content_done > #__wb_donate_close a:hover {
    color: #00B1F7 !important;
  }

/* Spinner */
#__wb_spinningSquaresG{        
  position: relative;
  width: 240px;
  height: 20px;
  
 
  padding: 0px !important;
  margin: 30px 0px 30px 160px !important;
  border: 0px !important;
  border-radius: 0px !important;
}

.__wb_spinningSquaresG {
   
      
  margin: 0px !important;
  padding: 0px !important;
  border: 0px !important;
  border-radius: 0px !important;
    
position:absolute;
top:0;
background-color:#000000;
width:22px;
height:22px;
-moz-animation-name:bounce_spinningSquaresG;
-moz-animation-duration:1.9s;
-moz-animation-iteration-count:infinite;
-moz-animation-direction:linear;
-moz-transform:scale(.3);
-webkit-animation-name:bounce_spinningSquaresG;
-webkit-animation-duration:1.9s;
-webkit-animation-iteration-count:infinite;
-webkit-animation-direction:linear;
-webkit-transform:scale(.3);
-ms-animation-name:bounce_spinningSquaresG;
-ms-animation-duration:1.9s;
-ms-animation-iteration-count:infinite;
-ms-animation-direction:linear;
-ms-transform:scale(.3);
-o-animation-name:bounce_spinningSquaresG;
-o-animation-duration:1.9s;
-o-animation-iteration-count:infinite;
-o-animation-direction:linear;
-o-transform:scale(.3);
animation-name:bounce_spinningSquaresG;
animation-duration:1.9s;
animation-iteration-count:infinite;
animation-direction:linear;
transform:scale(.3);
}

#__wb_spinningSquaresG_1{
left:0;
-moz-animation-delay:0.76s;
-webkit-animation-delay:0.76s;
-ms-animation-delay:0.76s;
-o-animation-delay:0.76s;
animation-delay:0.76s;
}

#__wb_spinningSquaresG_2{
left:30px;
-moz-animation-delay:0.95s;
-webkit-animation-delay:0.95s;
-ms-animation-delay:0.95s;
-o-animation-delay:0.95s;
animation-delay:0.95s;
}

#__wb_spinningSquaresG_3{
left:60px;
-moz-animation-delay:1.14s;
-webkit-animation-delay:1.14s;
-ms-animation-delay:1.14s;
-o-animation-delay:1.14s;
animation-delay:1.14s;
}

#__wb_spinningSquaresG_4{
left:90px;
-moz-animation-delay:1.33s;
-webkit-animation-delay:1.33s;
-ms-animation-delay:1.33s;
-o-animation-delay:1.33s;
animation-delay:1.33s;
}

#__wb_spinningSquaresG_5{
left:120px;
-moz-animation-delay:1.52s;
-webkit-animation-delay:1.52s;
-ms-animation-delay:1.52s;
-o-animation-delay:1.52s;
animation-delay:1.52s;
}

#__wb_spinningSquaresG_6{
left:150px;
-moz-animation-delay:1.71s;
-webkit-animation-delay:1.71s;
-ms-animation-delay:1.71s;
-o-animation-delay:1.71s;
animation-delay:1.71s;
}

#__wb_spinningSquaresG_7{
left:180px;
-moz-animation-delay:1.9s;
-webkit-animation-delay:1.9s;
-ms-animation-delay:1.9s;
-o-animation-delay:1.9s;
animation-delay:1.9s;
}

#__wb_spinningSquaresG_8{
left:210px;
-moz-animation-delay:2.09s;
-webkit-animation-delay:2.09s;
-ms-animation-delay:2.09s;
-o-animation-delay:2.09s;
animation-delay:2.09s;
}

@-moz-keyframes bounce_spinningSquaresG{
0%{
-moz-transform:scale(1);
background-color:#000000;
}

100%{
-moz-transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

@-webkit-keyframes bounce_spinningSquaresG{
0%{
-webkit-transform:scale(1);
background-color:#000000;
}

100%{
-webkit-transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

@-ms-keyframes bounce_spinningSquaresG{
0%{
-ms-transform:scale(1);
background-color:#000000;
}

100%{
-ms-transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

@-o-keyframes bounce_spinningSquaresG{
0%{
-o-transform:scale(1);
background-color:#000000;
}

100%{
-o-transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

@keyframes bounce_spinningSquaresG{
0%{
transform:scale(1);
background-color:#000000;
}

100%{
transform:scale(.3) rotate(90deg);
background-color:#FFFFFF;
}

}

 /* for SPN1 */

#wm-ipp-base {
  height:65px;/* initial height just in case js code fails */
  padding:0;
  margin:0;
  border:none;
  background:none transparent;
}
#wm-ipp {
  z-index: 2147483647;
}
#wm-ipp, #wm-ipp * {
  font-family:Lucida Grande, Helvetica, Arial, sans-serif;
  font-size:12px;
  line-height:1.2;
  letter-spacing:0;
  width:auto;
  height:auto;
  max-width:none;
  max-height:none;
  min-width:0 !important;
  min-height:0;
  outline:none;
  float:none;
  text-align:left;
  border:none;
  color: #000;
  text-indent: 0;
  position: initial;
  background: none;
}
#wm-ipp div, #wm-ipp canvas {
  display: block;
}
#wm-ipp div, #wm-ipp tr, #wm-ipp td, #wm-ipp a, #wm-ipp form {
  padding:0;
  margin:0;
  border:none;
  border-radius:0;
  background-color:transparent;
  background-image:none;
  /*z-index:2147483640;*/
  height:auto;
}
#wm-ipp table {
  border:none;
  border-collapse:collapse;
  margin:0;
  padding:0;
  width:auto;
  font-size:inherit;
}
#wm-ipp form input {
  padding:1px !important;
  height:auto;
  display:inline;
  margin:0;
  color: #000;
  background: none #fff;
  border: 1px solid #666;
}
#wm-ipp form input[type=submit] {
  padding:0 8px !important;
  margin:1px 0 1px 5px !important;
  width:auto !important;
  border: 1px solid #000 !important;
  background: #fff !important;
  color: #000 !important;
}
#wm-ipp form input[type=submit]:hover {
  background: #eee !important;
  cursor: pointer !important;
}
#wm-ipp form input[type=submit]:active {
  transform: translateY(1px);
}
#wm-ipp a {
  display: inline;
}    
#wm-ipp a:hover{
  text-decoration:underline;
}
#wm-ipp a.wm-btn:hover {
  text-decoration:none;
  color:#ff0 !important;
}
#wm-ipp a.wm-btn:hover span {
  color:#ff0 !important;
}
#wm-ipp #wm-ipp-inside {
  margin: 0 6px;
  border:5px solid #000;
  border-top:none;
  background-color:rgba(255,255,255,0.9);
  -moz-box-shadow:1px 1px 4px #333;
  -webkit-box-shadow:1px 1px 4px #333;
  box-shadow:1px 1px 4px #333;
  border-radius:0 0 8px 8px;
}
/* selectors are intentionally verbose to ensure priority */
#wm-ipp #wm-logo {
  padding:0 10px;
  vertical-align:middle;
  min-width:100px;
  flex: 0 0 100px;
}
#wm-ipp .c {
  padding-left: 4px;
}
#wm-ipp .c .u {
    margin-top: 4px !important;
}
#wm-ipp .n {
  padding:0 0 0 5px !important;
  vertical-align: bottom;
}
#wm-ipp .n a {
  text-decoration:none;
  color:#33f;
  font-weight:bold;
}
#wm-ipp .n .b {
  padding:0 6px 0 0 !important;
  text-align:right !important;
  overflow:visible;
  white-space:nowrap;
  color:#99a;
  vertical-align:middle;
}
#wm-ipp .n .y .b {
  padding:0 6px 2px 0 !important;
}
#wm-ipp .n .c {
  background:#000;
  color:#ff0;
  font-weight:bold;
  padding:0 !important;
  text-align:center;
}
#wm-ipp.hi .n td.c {
  color:#ec008c;
}
#wm-ipp .n td.f {
  padding:0 0 0 6px !important;
  text-align:left !important;
  overflow:visible;
  white-space:nowrap;
  color:#99a;
  vertical-align:middle;
}
#wm-ipp .n tr.m td {
  text-transform:uppercase;
  white-space:nowrap;
  padding:2px 0;
}
#wm-ipp .c .s {
  padding:0 5px 0 0 !important;
  vertical-align:bottom;
}
#wm-ipp #wm-nav-captures {
  white-space: nowrap;
}
#wm-ipp .c .s a.t {
  color:#33f;
  font-weight:bold;
  line-height: 1.8;
}
#wm-ipp .c .s div.r {
  color: #666;
  font-size:9px;
  white-space:nowrap;
}
#wm-ipp .c .k {
  padding-bottom:1px;
}
#wm-ipp .c .s {
  padding:0 5px 2px 0 !important;
}
#wm-ipp td#displayMonthEl {
  padding: 2px 0 !important;
}
#wm-ipp td#displayYearEl {
  padding: 0 0 2px 0 !important;
}

div#wm-ipp-sparkline {
  position:relative;/* for positioning markers */
  white-space:nowrap;
  background-color:#fff;
  cursor:pointer;
  line-height:0.9;
}
#sparklineImgId, #wm-sparkline-canvas {
  position:relative;
  z-index:9012;
  max-width:none;
}
#wm-ipp-sparkline div.yt {
  position:absolute;
  z-index:9010 !important;
  background-color:#ff0 !important;
  top: 0;
}
#wm-ipp-sparkline div.mt {
  position:absolute;
  z-index:9013 !important;
  background-color:#ec008c !important;
  top: 0;
}  
#wm-ipp .r {
    margin-left: 4px;
}
#wm-ipp .r a {
  color:#33f;
  border:none;
  position:relative;
  background-color:transparent;
  background-repeat:no-repeat !important;
  background-position:100% 100% !important;
  text-decoration: none;
}
#wm-ipp #wm-capinfo {
  /* prevents notice div background from sticking into round corners of
     #wm-ipp-inside */
  border-radius: 0 0 4px 4px;
}
#wm-ipp #wm-capinfo .c-logo {
  display:block;
  float:left;
  margin-right:3px;
  width:90px;
  min-height:90px;
  max-height: 290px;
  border-radius:45px;
  overflow:hidden;
  background-position:50%;
  background-size:auto 90px;
  box-shadow: 0 0 2px 2px rgba(208,208,208,128) inset;
}
#wm-ipp #wm-capinfo .c-logo span {
  display:inline-block;
}
#wm-ipp #wm-capinfo .c-logo img {
  height:90px;
  position:relative;
  left:-50%;
}
#wm-ipp #wm-capinfo .wm-title {
  font-size:130%;
}
#wm-ipp #wm-capinfo a.wm-selector {
  display:inline-block;
  color: #aaa;
  text-decoration:none !important;
  padding: 2px 8px;
}
#wm-ipp #wm-capinfo a.wm-selector.selected {
  background-color:#666;
}
#wm-ipp #wm-capinfo a.wm-selector:hover {
  color: #fff;
}
#wm-ipp #wm-capinfo.notice-only #wm-capinfo-collected-by,
#wm-ipp #wm-capinfo.notice-only #wm-capinfo-timestamps {
    display: none;
}
#wm-ipp #wm-capinfo #wm-capinfo-notice .wm-capinfo-content {
    background-color:#ff0;
    padding:5px;
    font-size:14px;
    text-align:center;
}
#wm-ipp #wm-capinfo #wm-capinfo-notice .wm-capinfo-content * {
    font-size:14px;
    text-align:center;
}
#wm-ipp #wm-expand {
  right: 1px;
  bottom: -1px;
  color: #ffffff;
  background-color: #666 !important;
  padding:0 5px 0 3px !important;
  border-radius: 3px 3px 0 0 !important;
}
#wm-ipp #wm-expand span {
  color: #ffffff;
}
#wm-ipp #wm-expand #wm-expand-icon {
  display: inline-block;
  transition: transform 0.5s;
  transform-origin: 50% 45%;
}
#wm-ipp #wm-expand.wm-open #wm-expand-icon {
  transform: rotate(180deg);
}
#wm-ipp #wmtb {
  text-align:right;
}
#wm-ipp #wmtb #wmtbURL {
  width: calc(100% - 45px);
}
#wm-ipp #wm-graph-anchor {
  border-right:1px solid #ccc;
}
/* time coherence */
html.wb-highlight {
  box-shadow: inset 0 0 0 3px #a50e3a !important;
}    
.wb-highlight {
  outline: 3px solid #a50e3a !important;
}
#wm-ipp-print {
  display:none !important;
}
@media print {
#wm-ipp-base {
  display:none !important;
}
#wm-ipp-print {
  display:block !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
}
@media (max-width:414px) {
    #wm-ipp .xxs {
	display:none !important;
    }
}
@media (min-width:1055px) {
#wm-ipp #wm-graph-anchor {
  display:block !important;
}
}
@media (max-width:1054px) {
#wm-ipp #wm-graph-anchor {
  display:none !important;
}
}
@media (max-width:1163px) {
#wm-logo {
    display:none !important;
}
}

#wm-btns {
    white-space: nowrap;
    margin-top: -2px;
}

#wm-btns #wm-save-snapshot-open {
  margin-right: 7px;
  top: -6px;
}

#wm-btns #wm-sign-in {
  box-sizing: content-box;
  display: none;
  margin-right: 7px;
  top: -8px;

  /*
  round border around sign in button
  */
  border: 2px #000 solid;
  border-radius: 14px;
  padding-right: 2px;
  padding-bottom: 2px;
  width: 11px;
  height: 11px;
}

#wm-btns #wm-sign-in>.iconochive-person {
  font-size: 12.5px;
}

#wm-save-snapshot-open > .iconochive-web {
  color:#000;
  font-size:160%;
}

#wm-ipp #wm-share {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
}

#wm-share > #wm-screenshot {
  display: inline-block;
  margin-right: 3px;
  visibility: hidden;
}

#wm-screenshot > .iconochive-image {
  color:#000;
  font-size:160%;
}

#wm-share > #wm-video {
  display: inline-block;
  margin-right: 3px;
  visibility: hidden;
}

#wm-video > .iconochive-movies {
  color: #000;
  display: inline-block;
  font-size: 150%;
  margin-bottom: 2px;
}

#wm-btns #wm-save-snapshot-in-progress {
  display: none;
  font-size:160%;
  opacity: 0.5;
  position: relative;
  margin-right: 7px;
  top: -5px;
}

#wm-btns #wm-save-snapshot-success {
  display: none;
  color: green;
  position: relative;
  top: -7px;
}

#wm-btns #wm-save-snapshot-fail {
  display: none;
  color: red;
  position: relative;
  top: -7px;
}

.wm-icon-screen-shot {
  background: /*savepage-url=../images/web-screenshot.svg*/ var(--savepage-url-8) no-repeat !important;
  background-size: contain !important;
  width: 22px !important;
  height: 19px !important;

  display: inline-block;
}
#donato {
    /* transition effect is disable so as to simplify height adjustment */
    /*transition: height 0.5s;*/
    height: 0;
    margin: 0;
    padding: 0;
    border-bottom: 1px solid #999 !important;
}
body.wm-modal {
    height: auto !important;
    overflow: hidden !important;
}
#donato #donato-base {
    width: 100%;
    height: 100%;
    /*bottom: 0;*/
    margin: 0;
    padding: 0;
    position: absolute;
    z-index: 2147483639;
}
body.wm-modal #donato #donato-base {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 2147483640;
}

.wb-autocomplete-suggestions {
    font-family: Lucida Grande, Helvetica, Arial, sans-serif;
    font-size: 12px;
    text-align: left;
    cursor: default;
    border: 1px solid #ccc;
    border-top: 0;
    background: #fff;
    box-shadow: -1px 1px 3px rgba(0,0,0,.1);
    position: absolute;
    display: none;
    z-index: 2147483647;
    max-height: 254px;
    overflow: hidden;
    overflow-y: auto;
    box-sizing: border-box;
}
.wb-autocomplete-suggestion {
    position: relative;
    padding: 0 .6em;
    line-height: 23px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 1.02em;
    color: #333;
}
.wb-autocomplete-suggestion b {
    font-weight: bold;
}
.wb-autocomplete-suggestion.selected {
    background: #f0f0f0;
}
</style><style data-savepage-href="/_static/css/iconochive.css?v=qtvMKcIJ" type="text/css">@font-face{font-family:'Iconochive-Regular';src:/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.eot?-ccsheb*/url();src:/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.eot?#iefix-ccsheb*/url() format('embedded-opentype'),/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.woff?-ccsheb*/url(data:application/octet-stream;base64,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) format('woff'),/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.ttf?-ccsheb*/url() format('truetype'),/*savepage-url=https://archive.org/includes/fonts/Iconochive-Regular.svg?-ccsheb#Iconochive-Regular*/url() format('svg');font-weight:normal;font-style:normal}
[class^="iconochive-"],[class*=" iconochive-"]{font-family:'Iconochive-Regular'!important;speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
.iconochive-Uplevel:before{content:"\21b5"}
.iconochive-exit:before{content:"\1f6a3"}
.iconochive-beta:before{content:"\3b2"}
.iconochive-logo:before{content:"\1f3db"}
.iconochive-audio:before{content:"\1f568"}
.iconochive-movies:before{content:"\1f39e"}
.iconochive-software:before{content:"\1f4be"}
.iconochive-texts:before{content:"\1f56e"}
.iconochive-etree:before{content:"\1f3a4"}
.iconochive-image:before{content:"\1f5bc"}
.iconochive-web:before{content:"\1f5d4"}
.iconochive-collection:before{content:"\2211"}
.iconochive-folder:before{content:"\1f4c2"}
.iconochive-data:before{content:"\1f5c3"}
.iconochive-tv:before{content:"\1f4fa"}
.iconochive-article:before{content:"\1f5cf"}
.iconochive-question:before{content:"\2370"}
.iconochive-question-dark:before{content:"\3f"}
.iconochive-info:before{content:"\69"}
.iconochive-info-small:before{content:"\24d8"}
.iconochive-comment:before{content:"\1f5e9"}
.iconochive-comments:before{content:"\1f5ea"}
.iconochive-person:before{content:"\1f464"}
.iconochive-people:before{content:"\1f465"}
.iconochive-eye:before{content:"\1f441"}
.iconochive-rss:before{content:"\221e"}
.iconochive-time:before{content:"\1f551"}
.iconochive-quote:before{content:"\275d"}
.iconochive-disc:before{content:"\1f4bf"}
.iconochive-tv-commercial:before{content:"\1f4b0"}
.iconochive-search:before{content:"\1f50d"}
.iconochive-search-star:before{content:"\273d"}
.iconochive-tiles:before{content:"\229e"}
.iconochive-list:before{content:"\21f6"}
.iconochive-list-bulleted:before{content:"\2317"}
.iconochive-latest:before{content:"\2208"}
.iconochive-left:before{content:"\2c2"}
.iconochive-right:before{content:"\2c3"}
.iconochive-left-solid:before{content:"\25c2"}
.iconochive-right-solid:before{content:"\25b8"}
.iconochive-up-solid:before{content:"\25b4"}
.iconochive-down-solid:before{content:"\25be"}
.iconochive-dot:before{content:"\23e4"}
.iconochive-dots:before{content:"\25a6"}
.iconochive-columns:before{content:"\25af"}
.iconochive-sort:before{content:"\21d5"}
.iconochive-atoz:before{content:"\1f524"}
.iconochive-ztoa:before{content:"\1f525"}
.iconochive-upload:before{content:"\1f4e4"}
.iconochive-download:before{content:"\1f4e5"}
.iconochive-favorite:before{content:"\2605"}
.iconochive-heart:before{content:"\2665"}
.iconochive-play:before{content:"\25b6"}
.iconochive-play-framed:before{content:"\1f3ac"}
.iconochive-fullscreen:before{content:"\26f6"}
.iconochive-mute:before{content:"\1f507"}
.iconochive-unmute:before{content:"\1f50a"}
.iconochive-share:before{content:"\1f381"}
.iconochive-edit:before{content:"\270e"}
.iconochive-reedit:before{content:"\2710"}
.iconochive-gear:before{content:"\2699"}
.iconochive-remove-circle:before{content:"\274e"}
.iconochive-plus-circle:before{content:"\1f5d6"}
.iconochive-minus-circle:before{content:"\1f5d5"}
.iconochive-x:before{content:"\1f5d9"}
.iconochive-fork:before{content:"\22d4"}
.iconochive-trash:before{content:"\1f5d1"}
.iconochive-warning:before{content:"\26a0"}
.iconochive-flash:before{content:"\1f5f2"}
.iconochive-world:before{content:"\1f5fa"}
.iconochive-lock:before{content:"\1f512"}
.iconochive-unlock:before{content:"\1f513"}
.iconochive-twitter:before{content:"\1f426"}
.iconochive-facebook:before{content:"\66"}
.iconochive-googleplus:before{content:"\67"}
.iconochive-reddit:before{content:"\1f47d"}
.iconochive-tumblr:before{content:"\54"}
.iconochive-pinterest:before{content:"\1d4df"}
.iconochive-popcorn:before{content:"\1f4a5"}
.iconochive-email:before{content:"\1f4e7"}
.iconochive-embed:before{content:"\1f517"}
.iconochive-gamepad:before{content:"\1f579"}
.iconochive-Zoom_In:before{content:"\2b"}
.iconochive-Zoom_Out:before{content:"\2d"}
.iconochive-RSS:before{content:"\1f4e8"}
.iconochive-Light_Bulb:before{content:"\1f4a1"}
.iconochive-Add:before{content:"\2295"}
.iconochive-Tab_Activity:before{content:"\2318"}
.iconochive-Forward:before{content:"\23e9"}
.iconochive-Backward:before{content:"\23ea"}
.iconochive-No_Audio:before{content:"\1f508"}
.iconochive-Pause:before{content:"\23f8"}
.iconochive-No_Favorite:before{content:"\2606"}
.iconochive-Unike:before{content:"\2661"}
.iconochive-Song:before{content:"\266b"}
.iconochive-No_Flag:before{content:"\2690"}
.iconochive-Flag:before{content:"\2691"}
.iconochive-Done:before{content:"\2713"}
.iconochive-Check:before{content:"\2714"}
.iconochive-Refresh:before{content:"\27f3"}
.iconochive-Headphones:before{content:"\1f3a7"}
.iconochive-Chart:before{content:"\1f4c8"}
.iconochive-Bookmark:before{content:"\1f4d1"}
.iconochive-Documents:before{content:"\1f4da"}
.iconochive-Newspaper:before{content:"\1f4f0"}
.iconochive-Podcast:before{content:"\1f4f6"}
.iconochive-Radio:before{content:"\1f4fb"}
.iconochive-Cassette:before{content:"\1f4fc"}
.iconochive-Shuffle:before{content:"\1f500"}
.iconochive-Loop:before{content:"\1f501"}
.iconochive-Low_Audio:before{content:"\1f509"}
.iconochive-First:before{content:"\1f396"}
.iconochive-Invisible:before{content:"\1f576"}
.iconochive-Computer:before{content:"\1f5b3"}
</style><div class="wb-autocomplete-suggestions "></div></template>
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20090418145854/http://www.sbin.org:80/doc/unix-faq/sockets-faq.html</div>
<script data-savepage-type="text/javascript" type="text/plain"></script>
<!-- END WAYBACK TOOLBAR INSERT -->

	<p style="text-align:right;float:right;">
	<a href="https://web.archive.org/web/20090418145854/http://www.sbin.org/">www.sbin.org</a>
	</p>

<center>
<img data-savepage-currentsrc="https://web.archive.org/web/20090418145854im_/http://www.sbin.org/doc/unix-faq/banner.png" data-savepage-src="/web/20090418145854im_/http://www.sbin.org/doc/unix-faq/banner.png" src="data:text/html;base64,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" alt="Self Serve FAQ" width="512" height="83"><br>
</center>
<p>
Welcome to the home of the UNIX Socket FAQ!  
</p><p>
<font size="+1"><b>The FAQ has moved to a <a href="https://web.archive.org/web/20090418145854/http://www.developerweb.net/forum/">phpBB forum</a>!  Please continue using it there.  This version of the FAQ will remain up so that you can reference old comments to the FAQ.</b></font></p><b>
<p>
Loco, Rob Seace and Michael Lampkin have done a tremendous amount of work getting the forum ready for everyone to use.  (Well, mostly Loco, but the other guys worked hard too!)  Go ahead and show them your appreciation in "The Lounge"!
</p><p>
You can download a single
file version of the faq <a data-savepage-href="flatfaq.php" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/flatfaq.php">here</a>.
</p><p>
The FAQ has two home pages.  The primary page is at
<a href="https://web.archive.org/web/20090418145854/http://www.developerweb.net/sock-faq/">http://www.developerweb.net/sock-faq/</a>.  The mirror is at
<a href="https://web.archive.org/web/20090418145854/http://www.ibrado.com/sock-faq/">http://www.ibrado.com/sock-faq/</a>.
For now the uncategorized questions and comments are only available at the
primary page.  I hope to add features to enable the mirror with all features.
Thanks for the mirror Alex!
</p><p>
If you are looking for Dr. Charles Campbell's Simple Sockets Library,
you can download version 2.09 <a data-savepage-href="ssl.tar.gz" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/ssl.tar.gz">here</a>.  If you are 
looking for the sample source for this faq, you can download it
<a data-savepage-href="examples.tar.gz" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/examples.tar.gz">here</a>.
</p><p>
</p><p>
<b>Categorized Questions:</b>
</p><p>
</p><ol>
<li>General Information and Concepts
<ol>
<li><a href="#faq1">What's new?</a> (Last updated April 16 2000)
</li><li><a href="#faq2">About this FAQ</a> (Last updated August 27 2001)
</li><li><a href="#faq3">Who is this FAQ for?</a> (Last updated   )
</li><li><a href="#faq4">What are Sockets?</a> (Last updated November 23 2001)
</li><li><a href="#faq5">How do Sockets Work?</a> (Last updated July 15 2002)
</li><li><a href="#faq6">Where can I get source code for the book [book title]?</a> (Last updated June 14 2000)
</li><li><a href="#faq7">Where can I get more information?</a> (Last updated December 17 2001)
</li><li><a href="#faq65">Where can I get the sample source code?</a> (Last updated March 4 2002)
</li></ol>
</li><li>Questions regarding both Clients and Servers (TCP/SOCK_STREAM)
<ol>
<li><a href="#faq8">How can I tell when a socket is closed on the other end?</a> (Last updated May 31 2002)
</li><li><a href="#faq9">What's with the second parameter in bind()?</a> (Last updated February 11 2000)
</li><li><a href="#faq10">How do I get the port number for a given service?</a> (Last updated   )
</li><li><a href="#faq11">If bind() fails, what should I do with the socket descriptor?</a> (Last updated November 9 2001)
</li><li><a href="#faq31">How do I properly close a socket?</a> (Last updated September 20 2001)
</li><li><a href="#faq12">When should I use shutdown()?</a> (Last updated April 14 2001)
</li><li><a href="#faq13">Please explain the TIME_WAIT state.</a> (Last updated April 22 1999)
</li><li><a href="#faq14">Why does it take so long to detect that the peer died?</a> (Last updated August 20 2001)
</li><li><a href="#faq15">What are the pros/cons of select(), non-blocking I/O and SIGIO?</a> (Last updated November 5 2001)
</li><li><a href="#faq16">Why do I get EPROTO from read()?</a> (Last updated December 7 1998)
</li><li><a href="#faq17">How can I force a socket to send the data in its buffer?</a> (Last updated December 7 1998)
</li><li><a href="#faq18">Where can I get a library for programming sockets?</a> (Last updated August 10 2001)
</li><li><a href="#faq19">How come select says there is data, but read returns zero?</a> (Last updated December 7 1998)
</li><li><a href="#faq20">Whats the difference between select() and poll()?</a> (Last updated December 7 1998)
</li><li><a href="#faq21">How do I send [this] over a socket</a> (Last updated June 19 2002)
</li><li><a href="#faq22">How do I use TCP_NODELAY?</a> (Last updated December 7 1998)
</li><li><a href="#faq23">What exactly does the Nagle algorithm do?</a> (Last updated December 7 1998)
</li><li><a href="#faq24">What is the difference between read() and recv()?</a> (Last updated November 15 2001)
</li><li><a href="#faq25">I see that send()/write() can generate SIGPIPE. Is there any advantage to handling the signal, rather than just ignoring it and checking for the EPIPE error?</a> (Last updated August 23 2001)
</li><li><a href="#faq26">After the chroot(), calls to socket() are failing.  Why?</a> (Last updated January 26 1999)
</li><li><a href="#faq27">Why do I keep getting EINTR from the socket calls?</a> (Last updated December 7 1998)
</li><li><a href="#faq28">When will my application receive SIGPIPE?</a> (Last updated December 7 1998)
</li><li><a href="#faq29">What are socket exceptions?  What is out-of-band data?</a> (Last updated December 7 1998)
</li><li><a href="#faq30">How can I find the full hostname (FQDN) of the system I'm running on?</a> (Last updated September 25 2000)
</li><li><a href="#faq83">How do I monitor the activity of sockets?</a> (Last updated December 21 1999)
</li></ol>
</li><li>Writing Client Applications (TCP/SOCK_STREAM)
<ol>
<li><a href="#faq32">How do I convert a string into an internet address?</a> (Last updated February 20 2002)
</li><li><a href="#faq33">How can my client work through a firewall/proxy server?</a> (Last updated January 1 1999)
</li><li><a href="#faq34">Why does connect() succeed even before my server did an accept()?</a> (Last updated December 7 1998)
</li><li><a href="#faq35">Why do I sometimes lose a server's address when using more than one server?</a> (Last updated August 22 2000)
</li><li><a href="#faq36">How can I set the timeout for the connect() system call?</a> (Last updated July 13 2000)
</li><li><a href="#faq37">Should I bind() a port number in my client program, or let the system choose one for me on the connect() call?</a> (Last updated June 14 2002)
</li><li><a href="#faq38">Why do I get "connection refused" when the server isn't running?</a> (Last updated December 7 1998)
</li><li><a href="#faq39">What does one do when one does not know how much information is comming over the socket?  Is there a way to have a dynamic buffer?</a> (Last updated January 18 2000)
</li><li><a href="#faq82">How can I determine the local port number?</a> (Last updated February 24 1999)
</li></ol>
</li><li>Writing Server Applications (TCP/SOCK_STREAM)
<ol>
<li><a href="#faq40">How come I get "address already in use" from bind()?</a> (Last updated March 6 2002)
</li><li><a href="#faq41">Why don't my sockets close?</a> (Last updated June 10 1999)
</li><li><a href="#faq42">How can I make my server a daemon?</a> (Last updated December 7 1998)
</li><li><a href="#faq43">How can I listen on more than one port at a time?</a> (Last updated August 23 2001)
</li><li><a href="#faq44">What exactly does SO_REUSEADDR do?</a> (Last updated December 7 1998)
</li><li><a href="#faq45">What exactly does SO_LINGER do?</a> (Last updated December 7 1998)
</li><li><a href="#faq46">What exactly does SO_KEEPALIVE do?</a> (Last updated October 17 2000)
</li><li><a href="#faq47">4.8 How can I bind() to a port number &lt; 1024?</a> (Last updated December 7 1998)
</li><li><a href="#faq48">How do I get my server to find out the client's address / hostname?</a> (Last updated September 25 1999)
</li><li><a href="#faq49">How should I choose a port number for my server?</a> (Last updated April 11 2000)
</li><li><a href="#faq50">What is the difference between SO_REUSEADDR and SO_REUSEPORT?</a> (Last updated December 7 1998)
</li><li><a href="#faq51">How can I write a multi-homed server?</a> (Last updated December 7 1998)
</li><li><a href="#faq52">How can I read only one character at a time?</a> (Last updated December 28 2001)
</li><li><a href="#faq53">I'm trying to exec() a program from my server, and attach my socket's IO to it, but I'm not getting all the data across.  Why?</a> (Last updated January 9 2002)
</li></ol>
</li><li>Writing UDP/SOCK_DGRAM applications
<ol>
<li><a href="#faq54">When should I use UDP instead of TCP?</a> (Last updated December 22 2001)
</li><li><a href="#faq55">What is the difference between "connected" and "unconnected" sockets?</a> (Last updated July 16 2002)
</li><li><a href="#faq56">Does doing a connect() call affect the receive behaviour of the socket?</a> (Last updated December 7 1998)
</li><li><a href="#faq57">How can I read ICMP errors from "connected" UDP sockets?</a> (Last updated October 27 2000)
</li><li><a href="#faq58">How can I be sure that a UDP message is received?</a> (Last updated December 12 2001)
</li><li><a href="#faq59">How can I be sure that UDP messages are received in order?</a> (Last updated November 9 2001)
</li><li><a href="#faq60">How often should I re-transmit un-acknowleged messages?</a> (Last updated November 28 2001)
</li><li><a href="#faq61">How come only the first part of my datagram is getting through?</a> (Last updated December 7 1998)
</li><li><a href="#faq62">Why does the socket's buffer fill up sooner than expected?</a> (Last updated December 7 1998)
</li></ol>
</li><li>Advanced Socket Programming
<ol>
<li><a href="#faq63">How would I put my socket in non-blocking mode?</a> (Last updated June 1 2002)
</li><li><a href="#faq64">How can I put a timeout on connect()?</a> (Last updated March 31 2002)
</li><li><a href="#faq66">How do I complete a read if I've only read the first part of something, without again calling select()?</a> (Last updated October 4 1999)
</li><li><a href="#faq69">How to use select routine</a> (Last updated February 22 2002)
</li><li><a href="#faq72">RAW sockets</a> (Last updated May 28 2002)
</li><li><a href="#faq76">Restricting a socket to a given interface</a> (Last updated February 23 2002)
</li><li><a href="#faq89">Receiving all incoming traffic through a RAW-socket?</a> (Last updated February 6 2001)
</li><li><a href="#faq91">Multicasting</a> (Last updated September 16 2001)
</li><li><a href="#faq108">getting IP header of a UDP message</a> (Last updated August 8 1999)
</li><li><a href="#faq120">To fork or not to fork?</a> (Last updated December 12 2001)
</li></ol>
</li><li>Sample Source Code
<ol>
<li><a href="#faq73">Looking for a good C++ socket library</a> (Last updated April 26 2002)
</li><li><a href="#faq79">perl examples of source code</a> (Last updated February 15 2001)
</li><li><a href="#faq102">Where is the source code from Richard Stevens' books?</a> (Last updated May 17 2000)
</li></ol>
</li><li>Bugs and Strange Behaviour
<ol>
<li><a href="#faq77">send() hangs up when sending to a switched off computer</a> (Last updated November 30 2001)
</li><li><a href="#faq80">Error when using inetd</a> (Last updated May 29 2002)
</li></ol></li></ol>
<p>
</p><h3>1. General Information and Concepts</h3>
<a name="faq1"><b>1. What's new?</b></a><p><a name="faq1">
You can find out what is new by looking at the main page
for questions that have been recently submitted.  You can
also set up a </a><a data-savepage-href="user.php3" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/user.php3">user profile</a> for yourself that will allow
the main page to tell you what questions have been added,
and which questions have new comments since your last
visit.</p><p>
</p><p>
<a name="faq2"><b>2. About this FAQ</b></a></p><p><a name="faq2">
This FAQ is maintained by Vic Metcalfe 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:vic@acm.org">vic@acm.org</a>), with lots of
assistance from Andrew Gierth 
(<a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>).
I am depending on the true
wizards to fill in the details, and correct my (no doubt) plentiful
mistakes.  The code examples in this FAQ are written to be easy to follow
and understand.  It is up to the reader to make them as efficient as
required.  I started this faq because after reading comp.unix.programmer 
for a short time, it became evident that a FAQ for sockets was needed.  </p>
<p>The FAQ is available at the following locations:</p>
<p>
</p><dl>
<dt><b>Usenet: (Posted on the 21st of each month)</b></dt><dd><p>news.answers, comp.answers, comp.unix.answers, comp.unix.programmer</p>

</dd><dt><b>FTP:</b></dt><dd><p>
<a href="https://web.archive.org/web/20090418145854/ftp://rtfm.mit.edu/pub/usenet/news.answers/unix-faq/socket">ftp://rtfm.mit.edu/pub/usenet/news.answers/unix-faq/socket</a></p>

</dd><dt><b>WWW:</b></dt><dd><p>
<a href="https://web.archive.org/web/20090418145854/http://www.ibrado.com/sock-faq">http://www.ibrado.com/sock-faq</a><br>
<a href="https://web.archive.org/web/20090418145854/http://kipper.york.ac.uk/~vic/sock-faq">http://kipper.york.ac.uk/~vic/sock-faq</a><br>
<a href="https://web.archive.org/web/20090418145854/http://www.ntua.gr/sock-faq">http://www.ntua.gr/sock-faq</a></p>
</dd></dl>
<p></p>
<p>Please 
<a href="https://web.archive.org/web/20090418145854/mailto:vic@acm.org">email me</a>
if you would like to correct or clarify an answer.  I 
would also like to hear from you if you would like me to add a question 
to the list.  I may not be able to answer it, but I can add it in the 
hopes that someone else will submit an answer.  Every hour I seem to be 
getting even busier, so if I am slow to respond to your email, please be 
patient.  If more than a week passes you may want to send me another one 
as I often put messages aside for later and then forget about them.  I'll 
have to work on dealing with my mail better, but until then feel free to 
pester me a little bit.</p><p>
</p><p>
<a name="faq3"><b>3. Who is this FAQ for?</b></a></p><p><a name="faq3">
This FAQ is for C programmers in the Unix environment.  It is not intended
for WinSock programmers, or for Perl, Java, etc.  I have nothing against
Windows or Perl, but I had to limit the scope of the FAQ for the first
draft.  In the future, I would really like to provide examples for Perl,
Java, and maybe others.  For now though I will concentrate on correctness 
and completeness for C. </a></p><a name="faq3">
<p>This version of the FAQ will only cover sockets of the AF_INET family,
since this is their most common use.  Coverage of other types of sockets
may be added later. </p><p>
</p></a><p><a name="faq3">
</a><a name="faq4"><b>4. What are Sockets?</b></a></p><p><a name="faq4">
Sockets are just like "worm holes" in science fiction.  When things go
into one end, they (should) come out of the other.  Different kinds of
sockets have different properties.  Sockets are either connection-oriented
or connectionless.  Connection-oriented sockets allow for data to flow
back and forth as needed, while connectionless sockets (also known as
datagram sockets) allow only one message at a time to be transmitted,
without an open connection.  There are also different socket families. 
The two most common are <code>AF_INET</code> for internet connections, and 
<code>AF_UNIX</code> for
unix IPC (interprocess communication).  As stated earlier, this FAQ deals
only with <code>AF_INET</code> sockets.</a></p><p><a name="faq4">
</a></p><p><a name="faq4">
</a><a name="faq5"><b>5. How do Sockets Work?</b></a></p><p><a name="faq5">
The implementation is left up to the vendor of your particular unix, but
from the point of view of the programmer, connection-oriented sockets work
a lot like files, or pipes.  The most noticeable difference, once you have 
your file descriptor is that <code>read()</code> or <code>write()</code> calls may actually 
read or 
write fewer bytes than requested.  If this happens, then you will have to 
make a second call for the rest of the data.  There are examples of this 
in the 
</a><a data-savepage-href="detail.php3?id=65" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=65">source code that accompanies the faq</a>.
</p><p>
</p><p>
<a name="faq6"><b>6. Where can I get source code for the book [book title]?</b></a></p><p><a name="faq6">
Here is a list of the places I know to get source code for network
programming books.  It is very short, so please mail me with any others
you know of. </a></p><a name="faq6">
</a><p><a name="faq6">Title: Unix Network Programming<br>
Author: W. Richard Stevens 
(
</a><a href="https://web.archive.org/web/20090418145854/mailto:rstevens@kohala.com">rstevens@kohala.com</a>)<br>
Publisher: Prentice Hall, Inc.<br>
ISBN: 0-13-949876-1<br>
URL: 
<a href="https://web.archive.org/web/20090418145854/http://www.kohala.com/~rstevens">http://www.kohala.com/~rstevens</a></p>
<p>Title: Power Programming with RPC<br>
Author: John Bloomer<br>
Publisher: O'Reilly &amp; Associates, Inc.<br>
ISBN: 0-937175-77-3<br>
URL: 
<a href="https://web.archive.org/web/20090418145854/ftp://ftp.uu.net/published/oreilly/nutshell/rpc/rpc.tar.Z">ftp://ftp.uu.net/published/oreilly/nutshell/rpc/rpc.tar.Z</a></p>
<p>Recommended by: 
Lokmanm Merican (lokmanm#pop4.jaring.my@199.1.1.88)<br>
Title: UNIX PROGRAM DEVELOPMENT for IBM PC'S Including OSF/Motif<br>
Author: Thomas Yager<br>
Publisher: Addison Wesley, 1991<br>
ISBN: 0-201-57727-5<br></p><p>
</p><p>
<a name="faq7"><b>7. Where can I get more information?</b></a></p><p><a name="faq7">
I keep a copy of the resources I know of on my socks page on the web.  I 
don't remember where I got most of these items, but some day I'll check 
out their sources, and provide ftp information here.  For now, you can 
get them at 
</a><a href="https://web.archive.org/web/20090418145854/http://www.ibrado.com/sock-faq">http://www.ibrado.com/sock-faq</a>.</p>
<p>There is a TCP/IP FAQ which
can be found at
<a href="https://web.archive.org/web/20090418145854/http://www.dc.net/ilazar/tcpipfaq/default.htm">http://www.dc.net/ilazar/tcpipfaq/default.htm</a>
</p><p>
</p><p>
<a name="faq65"><b>8. Where can I get the sample source code?</b></a></p><p><a name="faq65">
The sample source code is no longer included in the faq.  To get it, 
please download it from the unix-socket-faq www page at </a><a href="https://web.archive.org/web/20090418145854/http://www.developerweb.net/sock-faq/">http://www.developerweb.net/sock-faq/</a></p>
<p>If you don't have web access, you can ftp it with ftpmail by following 
the following instructions.</p>
<p>To get the sample source by mail, send mail to 
<a href="https://web.archive.org/web/20090418145854/mailto:ftpmail@decwrl.dec.com">ftpmail@decwrl.dec.com</a>, 
with no subject line and a body like this:</p>
<p>
</p><blockquote><code>
<pre>  reply <put your="" email="" address="" here="">
  connect ftp.zymsys.com
  binary
  uuencode
  get pub/sockets/examples.tar.gz
  quit
</put></pre>
</code></blockquote>
<p></p>
<p>Save the reply as examples.uu, and type:</p>
<p>
</p><blockquote><code>
<pre>  % uudecode examples.uu
  % gunzip examples.tar.gz
  % tar xf examples.tar
</pre>
</code></blockquote>
<p></p>
<p>This will create a directory called socket-faq-examples which contains the
sample code from this faq, plus a sample client and server for both tcp and
udp.</p>
<p>Note that this package requires the gnu unzip program to be installed on 
your system.  It is very common, but if you don't have it you can get the 
source for it from:</p>
<p>
</p><blockquote>
<a href="https://web.archive.org/web/20090418145854/ftp://prep.ai.mit.edu/pub/gnu/gzip-1.2.4.tar">ftp://prep.ai.mit.edu/pub/gnu/gzip-1.2.4.tar</a></blockquote>
<p></p>
<p>If you don't have ftp access, you can obtain it in a way similar to 
obtaining the sample source.  I'll leave the exact changes to the body of 
the message as an excersise for the reader.</p><p>
</p><p>
</p><h3>2. Questions regarding both Clients and Servers (TCP/SOCK_STREAM)</h3>
<a name="faq8"><b>1. How can I tell when a socket is closed on the other end?</b></a><p><a name="faq8">
From Andrew Gierth 
(
</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>AFAIK:</p>
<p>If the peer calls <code>close()</code> or exits, without having messed with 
<code>SO_LINGER</code>,
then our calls to <code>read()</code> should return 0. It is less clear what happens
to <code>write()</code> calls in this case; I would expect <code>EPIPE</code>, not on the 
next call, but the one after.</p>
<p>If the peer reboots, or sets <code>l_onoff = 1, l_linger = 0</code> and then closes,
then we should get <code>ECONNRESET</code> (eventually) from <code>read()</code>, or 
<code>EPIPE</code> from <code>write()</code>.</p>
<p>I should also point out that when <code>write()</code> returns <code>EPIPE</code>, it also
raises the <code>SIGPIPE</code> signal - you never see the <code>EPIPE</code> error 
unless you handle or ignore the signal.</p>
<p>If the peer remains unreachable, we should get some other 
error.             </p>
<p>I don't think that <code>write()</code> can legitimately return 0.  <code>read()</code> 
should
return 0 on receipt of a FIN from the peer, and on all following calls.</p>
<p>So yes, you <b>must</b> expect <code>read()</code> to return 0.</p>
<p>As an example, suppose you are receiving a file down a TCP link; you
might handle the return from <code>read()</code> like this:</p>
<p>
</p><blockquote><code>
<pre>rc = read(sock,buf,sizeof(buf));
if (rc &gt; 0)
{
    write(file,buf,rc);
    /* error checking on file omitted */
}
else if (rc == 0)
{
    close(file);
    close(sock);
    /* file received successfully */
}
else /* rc &lt; 0 */
{
    /* close file and delete it, since data is not complete
       report error, or whatever */
}
</pre>
</code></blockquote>
<p>
</p><p>
<a name="faq9"><b>2. What's with the second parameter in bind()?</b></a></p><p><a name="faq9">
The man page shows it as "<code>struct sockaddr *my_addr</code>".  The 
<code>sockaddr struct</code>
though is just a place holder for the structure it really wants.  You have
to pass different structures depending on what kind of socket you have.
For an <code>AF_INET</code> socket, you need the sockaddr_in structure.  It has three
fields of interest:</a></p><a name="faq9">
<p>
</p><dl>
<dt><b>sin_family</b></dt><dd><p>Set this to <code>AF_INET</code>.</p>
</dd><dt><b>sin_port</b></dt><dd><p>The network byte-ordered 16 bit port number</p>
</dd><dt><b>sin_addr</b></dt><dd><p>The host's ip number.  This is a <code>struct in_addr</code>, which
contains only one field, <code>s_addr</code> which is a <code>u_long</code>.</p>
</dd></dl>
<p>
</p></a><p><a name="faq9">
</a><a name="faq10"><b>3. How do I get the port number for a given service?</b></a></p><p><a name="faq10">


Use the <code>getservbyname()</code> routine.  This will return a pointer to a 
<code>servent</code>
structure.  You are interested in the <code>s_port</code> field, which contains the 
port number, with correct byte ordering (so you don't need to call 
<code>htons()</code> on it).  Here is a sample routine:</a></p><a name="faq10">
<p>
</p><blockquote><code>
<pre>/* Take a service name, and a service type, and return a port number.  If the
   service name is not found, it tries it as a decimal number.  The number
   returned is byte ordered for the network. */
int atoport(char *service, char *proto) {
  int port;
  long int lport;
  struct servent *serv;
  char *errpos;

  /* First try to read it from /etc/services */
  serv = getservbyname(service, proto);
  if (serv != NULL)
    port = serv-&gt;s_port;
  else { /* Not in services, maybe a number? */
    lport = strtol(service,&amp;errpos,0);
    if ( (errpos[0] != 0) || (lport &lt; 1) || (lport &gt; 5000) )
      return -1; /* Invalid port address */
    port = htons(lport);
  }
  return port;
}
</pre>
</code></blockquote><p>
</p></a><p><a name="faq10">
</a><a name="faq11"><b>4. If bind() fails, what should I do with the socket descriptor?</b></a></p><p><a name="faq11">
If you are exiting, I have been assured by Andrew that all unixes will 
close open file descriptors on exit.  If you are not exiting though, you 
can just close it with a regular <code>close()</code> call.</a></p><a name="faq11">
<p>
</p></a><p><a name="faq11">
</a><a name="faq31"><b>5. How do I properly close a socket?</b></a></p><p><a name="faq31">
This question is usually asked by people who try <code>close()</code>, because they 
have seen that that is what they are supposed to do, and then run netstat 
and see that their socket is still active.  Yes, <code>close()</code> is the correct 
method.  To read about the TIME_WAIT state, and why it is important, 
refer to 
</a><a data-savepage-href="detail.php3?id=13" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=13">2.7 Please explain the TIME_WAIT state.</a>.</p><p>
</p><p>
<a name="faq12"><b>6. When should I use shutdown()?</b></a></p><p><a name="faq12">
From Michael Hunter 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:mphunter@qnx.com">mphunter@qnx.com</a>):</p>
<p><code>shutdown()</code> is useful for deliniating when you are done providing a 
request
to a server using TCP.  A typical use is to send a request to a server
followed by a <code>shutdown()</code>.  The server will read your request 
followed by
an <code>EOF</code> (read of 0 on most unix implementations).  This tells the server
that it has your full request.  You then go read blocked on the socket. 
The server will process your request and send the necessary data back to
you followed by a close.  When you have finished reading all of the
response to your request you will read an <code>EOF</code> thus signifying that you
have the whole response.  It should be noted the TTCP (TCP for
Transactions -- see R. Steven's home page) provides for a better method of
tcp transaction management. </p>
<p>S.Degtyarev (<a data-savepage-href="deg@sunsr.inp.nsk.su" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/deg@sunsr.inp.nsk.su">deg@sunsr.inp.nsk.su</a>) wrote a nice in-depth message to me
about this.  He shows a practical example of using shutdown() to aid in
synchronization of client processes when one is the "reader" process, and
the other is the "writer" process.  A portion of his message follows:</p>
<p>Sockets are very similar to pipes in the way they are used for data
transfer and client/server transactions, but not like pipes they are
bidirectional.  Programs that use sockets often <code>fork()</code> and each
process inherits the socket descriptor.  In pipe based programs it is
strictly recommended to close all the pipe ends that are not used to
convert the pipe line to one-directional data stream to avoid data losses
and deadlocks.  With the socket there is no way to allow one process only
to send data and the other only to receive so you should always keep in
mind the consequences. </p>
<p>Generally the difference between <code>close()</code> and <code>shutdown()</code> is: 
<code>close()</code> closes the socket id for the process but the connection is
still opened if another process shares this socket id.  The connection
stays opened both for read and write, and sometimes this is very
important.  <code>shutdown()</code> breaks the connection for all processes
sharing
the socket id.  Those who try to read will detect <code>EOF</code>, and those
who
try to write will reseive <code>SIGPIPE</code>, possibly delayed while the kernel
socket buffer will be filled.  Additionally, <code>shutdown()</code> has a second
argument
which denotes how to close the connection: 0 means to disable further
reading, 1 to disable writing and 2 disables both. </p>
<p>The quick example below is a fragment of a very simple client process.
After establishing the connection with the server it forks.  Then child
sends the keyboard input to the server until <code>EOF</code> is received and the
parent receives answers from the server. </p>
<p>
</p><blockquote><code>
<pre>/*
 *      Sample client fragment,
 *      variables declarations and error handling are omitted
 */
        s=connect(...);

        if( fork() ){   /*      The child, it copies its stdin to
                                        the socket              */
                while( gets(buffer) &gt;0)
                        write(s,buf,strlen(buffer));

                close(s);
                exit(0);
                }

        else {          /* The parent, it receives answers  */
                while( (l=read(s,buffer,sizeof(buffer)){
                        do_something(l,buffer);

                /* Connection break from the server is assumed  */
                /* ATTENTION: deadlock here                     */
                wait(0); /* Wait for the child to exit          */
                exit(0);
                }
</pre>
</code></blockquote>
<p></p>
<p>What do we expect? The child detects an <code>EOF</code> from its <code>stdin</code>, it
closes the socket (assuming connection break) and exits.  The server in
its
turn detects <code>EOF</code>, closes connection and exits.  The parent detects
<code>EOF</code>, makes the <code>wait()</code> system call and exits.  What do we see
instead?  The socket instance in the parent process is still opened for
writing and reading, though the parent never writes.  The server never
detects EOF and waits for more data from the client forever.  The parent
never sees the connection is closed and hangs forever and the server hangs
too.  Unexpected deadlock!  ( any deadlock is unexpected though :-) </p>
<p>You should change the client fragment as follows:</p>
<p>
</p><blockquote><code>
<pre>                if( fork() ) {  /* The child                    */
                        while( gets(buffer) }
                                write(s,buffer,strlen(buffer));

                                shutdown(s,1); /* Break the connection
        for writing, The server will detect EOF now. Note: reading from
        the socket is still allowed. The server may send some more data
        after receiving EOF, why not? */
                        exit(0);
                        }
</pre>
</code></blockquote>
<p></p>
<p>I hope this rough example explains the troubles you can have with
client/server syncronization.  Generally you should always remember all
the instances of the particular socket in all the processes that share
the socket and close them all at once if you whish to use close() or use
shutdown() in one process to break the connection.</p><p>
</p><p>
<a name="faq13"><b>7. Please explain the TIME_WAIT state.</b></a></p><p><a name="faq13">
Remember that TCP guarantees all data transmitted will be delivered, if at
all possible.  When you close a socket, the server goes into a TIME_WAIT
state, just to be really really sure that all the data has gone through. 
When a socket is closed, both sides agree by sending messages to each
other that they will send no more data.  This, it seemed to me was good
enough, and after the handshaking is done, the socket should be closed. 
The problem is two-fold.  First, there is no way to be sure that the last 
ack was communicated successfully.  Second, there may be "wandering 
duplicates" left on the net that must be dealt with if they are delivered.</a></p><a name="faq13">
</a><p><a name="faq13">Andrew Gierth 
(
</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>) helped to explain the closing 
sequence in the following usenet posting:</p>
<p>Assume that a connection is in ESTABLISHED state, and the client is 
about
to do an orderly release. The client's sequence no. is Sc, and the server's
is Ss. The pipe is empty in both directions.</p>
<p>
</p><blockquote><code>
<pre>   Client                                                   Server
   ======                                                   ======
   ESTABLISHED                                              ESTABLISHED
   (client closes)
   ESTABLISHED                                              ESTABLISHED
                <ctl=fin+ack><seq=sc><ack=ss> -------&gt;&gt;
   FIN_WAIT_1
                &lt;&lt;-------- <ctl=ack><seq=ss><ack=sc+1>
   FIN_WAIT_2                                               CLOSE_WAIT
                &lt;&lt;-------- <ctl=fin+ack><seq=ss><ack=sc+1>  (server closes)
                                                            LAST_ACK
                <ctl=ack>,<seq=sc+1><ack=ss+1> -------&gt;&gt;
   TIME_WAIT                                                CLOSED
   (2*msl elapses...)
   CLOSED
</ack=ss+1></seq=sc+1></ctl=ack></ack=sc+1></seq=ss></ctl=fin+ack></ack=sc+1></seq=ss></ctl=ack></ack=ss></seq=sc></ctl=fin+ack></pre>
</code></blockquote>
<p></p>
<p>Note: the +1 on the sequence numbers is because the FIN counts as 
one 
byte of data. (The above diagram is equivalent to fig. 13 from RFC 793).</p>
<p>Now consider what happens if the last of those packets is dropped in the
network. The client has done with the connection; it has no more data or
control info to send, and never will have. But the server does not know
whether the client received all the data correctly; that's what the last
ACK segment is for. Now the server may or may not <em>care</em> whether the
client got the data, but that is not an issue for TCP; TCP is a reliable
rotocol, and <em>must</em> distinguish between an orderly connection <b>close</b>
where all data is transferred, and a connection <b>abort</b> where data may
or may not have been lost.</p>
<p>So, if that last packet is dropped, the server will retransmit it (it is,
after all, an unacknowledged segment) and will expect to see a suitable
ACK segment in reply.  If the client went straight to CLOSED, the 
only
possible response to that retransmit would be a RST, which would 
indicate
to the server that data had been lost, when in fact it had not been.</p>
<p>(Bear in mind that the server's FIN segment may, additionally, contain
data.)</p>
<p>DISCLAIMER: This is my interpretation of the RFCs (I have read all the
TCP-related ones I could find), but I have not attempted to examine
implementation source code or trace actual connections in order to
verify it. I am satisfied that the logic is correct, though.</p>
<p>More commentarty from Vic:</p>
<p>The second issue was addressed by Richard Stevens 
(
<a href="https://web.archive.org/web/20090418145854/mailto:rstevens@noao.edu">rstevens@noao.edu</a>,
author of "Unix Network Programming", see
<a data-savepage-href="detail.php3?id=6" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=6">1.6 Where can I get source code for the book [book  title]?</a>).
I have put 
together quotes from some
of his postings and email which explain this.  I have brought together
paragraphs from different postings, and have made as few changes as 
possible.</p>
<p>From Richard Stevens 
(
<a href="https://web.archive.org/web/20090418145854/mailto:rstevens@noao.edu">rstevens@noao.edu</a>):</p>
<p>If the duration of the TIME_WAIT state were just to handle TCP's 
full-duplex 
close, then the time would be much smaller, and it would be some function 
of the current RTO (retransmission timeout), not the MSL (the 
packet lifetime).</p>
<p>A couple of points about the TIME_WAIT state.</p>
<p>
</p><ul>
<li>The end that sends the first FIN goes into the TIME_WAIT 
state, because that
is the end that sends the final ACK.  If the other end's 
FIN is lost, or
if the final ACK is lost, having the end that sends the first FIN 
maintain state about the connection guarantees that it has enough 
information to retransmit the final ACK.
</li>
<li>Realize that TCP sequence numbers wrap around after 2**32 bytes have 
been transferred.  Assume a connection between A.1500 (host A, port 
1500) and B.2000.  During the connection one segment is lost and 
retransmitted.  But the segment is not really lost, it is held by 
some intermediate router and then re-injected into the network.  (This 
is called a "wandering duplicate".)  But in the time between the 
packet being lost &amp; retransmitted, and then reappearing, the 
connection is closed (without any problems) and then another 
connection is established between the same host, same port (that is, 
A.1500 and B.2000; this is called another "incarnation" of the 
connection).  But the sequence numbers chosen for the new incarnation 
just happen to overlap with the sequence number of the wandering 
duplicate that is about to reappear.  (This is indeed possible, given 
the way sequence numbers are chosen for TCP connections.)  Bingo, you 
are about to deliver the data from the wandering duplicate (the 
previous incarnation of the connection) to the new incarnation of the 
connection.  To avoid this, you do not allow the same incarnation of 
the connection to be reestablished until the TIME_WAIT state terminates.

Even the TIME_WAIT state doesn't complete solve the second problem, 
given what is called TIME_WAIT assassination.  RFC 1337 has more 
details.
</li>
<li>The reason that the duration of the TIME_WAIT state is 2*MSL is 
that the 
maximum amount of time a packet can wander around a network is 
assumed to be MSL seconds.  The factor of 2 is for the round-trip.  
The recommended value for MSL is 120 seconds, but Berkeley-derived 
implementations normally use 30 seconds instead.  This means a 
TIME_WAIT 
delay between 1 and 4 minutes.  Solaris 2.x does indeed use the 
recommended MSL of 120 seconds.</li>
</ul>
<p></p>
<p>A wandering duplicate is a packet that appeared to be lost and was
retransmitted.  But it wasn't really lost ... some router had problems,
held on to the packet for a while (order of seconds, could be a minute
if the TTL is large enough) and then re-injects the packet back into
the network.  But by the time it reappears, the application that sent
it originally has already retransmitted the data contained in that packet.</p>
<p>Because of these potential problems with TIME_WAIT assassinations, one 
should 
<em>not</em> avoid the TIME_WAIT state by setting the <code>SO_LINGER</code> 
option to send an 
RST instead of the normal TCP connection termination 
(FIN/ACK/FIN/ACK).  
The TIME_WAIT state is there for a reason; it's your friend and it's 
there to help you :-)</p>
<p>I have a long discussion of just this topic in my just-released "TCP/IP
Illustrated, Volume 3".  The TIME_WAIT state is indeed, one of the most
misunderstood features of TCP.</p>
<p>I'm currently rewriting "Unix Network Programming" (see
<a data-savepage-href="detail.php3?id=6" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=6">1.6 Where can I get source code for the book [book  title]?</a>). and 
will include 
lots more on this topic, as it is often confusing and misunderstood.</p>
<p>An additional note from Andrew:</p>
<p><b>Closing a socket:</b> if <code>SO_LINGER</code> has not been called on a socket, 
then
<code>close()</code> is not supposed to discard data. This is true on SVR4.2 
(and,
apparently, on all non-SVR4 systems) but apparently <b>not</b> on 
SVR4; the
use of either <code>shutdown()</code> or <code>SO_LINGER</code> seems to be required to
guarantee delivery of all data.</p><p>
</p><p>
<a name="faq14"><b>8. Why does it take so long to detect that the peer died?</b></a></p><p><a name="faq14">

From Andrew Gierth 
(
</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>Because by default, no packets are sent on the TCP connection unless there
is data to send or acknowledge.</p>
<p>So, if you are simply waiting for data from the peer, there is no way to
tell if the peer has silently gone away, or just isn't ready to send any
more data yet. This can be a problem (especially if the peer is a PC, and
the user just hits the Big Switch...).</p>
<p>One solution is to use the <code>SO_KEEPALIVE</code> option. This option enables
periodic probing of the connection to ensure that the peer is still present.
<b>BE WARNED:</b> the default timeout for this option is <b>AT LEAST 2 HOURS</b>.
This timeout can often be altered (in a system-dependent fashion) but not
normally on a per-connection basis (AFAIK).</p>
<p>RFC1122 specifies that this timeout (if it exists) must be configurable.
On the majority of Unix variants, this configuration may only be done
globally, affecting all TCP connections which have keepalive enabled. The
method of changing the value, moreover, is often difficult and/or poorly
documented, and in any case is different for just about every version in
existence. </p>
<p>If you must change the value, look for something resembling <code>tcp_keepidle</code>
in your kernel configuration or network options configuration. </p>
<p>If you're <em>sending</em> to the peer, though, you have some better guarantees;
since sending data implies receiving ACKs from the peer, then you will 
know after the retransmit timeout whether the peer is still alive. But the
retransmit timeout is designed to allow for various contingencies, with the
intention that TCP connections are not dropped simply as a result of minor
network upsets. So you should still expect a delay of several minutes before
getting notification of the failure.</p>
<p>The approach taken by most application protocols currently in use on the
Internet (e.g. FTP, SMTP etc.) is to implement read timeouts on the server
end; the server simply gives up on the client if no requests are received in
a given time period (often of the order of 15 minutes). Protocols where the
connection is maintained even if idle for long periods have two choices:</p>
<p>
</p><ol>
<li>use <code>SO_KEEPALIVE</code></li>
<li>use a higher-level keepalive mechanism (such as sending a null request
to the server every so often).</li>
</ol><p>
</p><p>
<a name="faq15"><b>9. What are the pros/cons of select(), non-blocking I/O and SIGIO?</b></a></p><p><a name="faq15">


Using non-blocking I/O means that you have to poll sockets to see if 
there is data to be read from them.  Polling should usually be avoided 
since it uses more CPU time than other techniques.  </a></p><a name="faq15">
<p>Using <code>SIGIO</code> allows your application to do what it does and have the
operating system tell it (with a signal) that there is data waiting for it
on a socket.  The only drawback to this soltion is that it can be
confusing, and if you are dealing with multiple sockets you will have to
do a <code>select()</code> anyway to find out which one(s) is ready to be read. </p>
<p>Using <code>select()</code> is great if your application has to accept data from more
than one socket at a time since it will block until any one of a number of
sockets is ready with data.  One other advantage to <code>select()</code> is that you
can set a time-out value after which control will be returned to you
whether any of the sockets have data for you or not.</p><p>
</p></a><p><a name="faq15">
</a><a name="faq16"><b>10. Why do I get EPROTO from read()?</b></a></p><p><a name="faq16">
From Steve Rago (</a><a href="https://web.archive.org/web/20090418145854/mailto:sar@plc.com">sar@plc.com</a>):</p>
<p><code>EPROTO</code> means that the protocol encountered an unrecoverable error
for that endpoint.  <code>EPROTO</code> is one of those catch-all error codes
used by STREAMS-based drivers when a better code isn't available.</p>
<p>And an addition note from Andrew
(<a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>Not quite to do with <code>EPROTO</code> from <code>read()</code>, but I found out once that
on some STREAMS-based implementations, <code>EPROTO</code> could be returned by
<code>accept()</code> if the incoming connection was reset before the accept
completes.</p>
<p>On some other implementations, accept seemed to be capable of blocking
if this occured. This is important, since if <code>select()</code> said the listening
socket was readable, then you would normally expect <em>not</em> to block in
the <code>accept()</code> call. The fix is, of course, to set nonblocking mode on
the listening socket if you are going to use <code>select()</code> on it.</p><p>
</p><p>
<a name="faq17"><b>11. How can I force a socket to send the data in its buffer?</b></a></p><p><a name="faq17">
From Richard Stevens 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:rstevens@noao.edu">rstevens@noao.edu</a>):</p>
<p>You can't force it.  Period.  TCP makes up its own mind as to when
it can send data.  Now, <em>normally</em> when you call <code>write()</code> on a TCP
socket, TCP will indeed send a segment, but there's no guarantee
and no way to force this.  There are <em>lots</em> of reasons why TCP
will not send a segment: a closed window and the Nagle algorithm
are two things to come immediately to mind.  </p>
<p>(Snipped suggestion from Andrew Gierth to use <code>TCP_NODELAY</code>)</p>
<p>Setting this only disables one of the many tests, the Nagle algorithm.
But if the original poster's problem is this, then setting this socket
option will help.</p>
<p>A quick glance at tcp_output() shows around 11 tests TCP has to make
as to whether to send a segment or not.</p>
<p>Now from Dr. Charles E. Campbell Jr. 
(<a href="https://web.archive.org/web/20090418145854/mailto:cec@gryphon.gsfc.nasa.gov">cec@gryphon.gsfc.nasa.gov</a>):</p>
<p>As you've surmised, I've never had any problem with disabling Nagle's
algorithm.  Its basically a buffering method; there's a fixed overhead 
for all packets, no matter how small.  Hence, Nagle's algorithm 
collects small packets together (no more than .2sec delay) and thereby 
reduces the amount of overhead bytes being transferred.  This approach 
works well for rcp, for example: the .2 second delay isn't humanly 
noticeable, and multiple users have their small packets more 
efficiently transferred.  Helps in university settings where most folks 
using the network are using standard tools such as rcp and ftp, and 
programs such as telnet may use it, too.</p>
<p>However, Nagle's algorithm is pure havoc for real-time control and not much
better for keystroke interactive applications (control-C, anyone?).  It has
seemed to me that the types of new programs using sockets that people write
usually do have problems with small packet delays.  One way to bypass 
Nagle's algorithm selectively is to use "out-of-band" messaging, but 
that is limited in its content and has other effects (such as a loss of 
sequentiality) (by the way, out-of-band is often used for that ctrl-C, 
too).</p>
<p>More from Vic:</p>
<p>So to sum it all up, if you are having trouble and need to flush the 
socket, setting the <code>TCP_NODELAY</code> option will usually solve the problem.  
If it doesn't, you will have to use out-of-band messaging, but according 
to Andrew, "out-of-band data has its own problems, and I don't think it 
works well as a solution to buffering delays (haven't tried it though). 
It is <em>not</em> 'expedited data' in the sense that exists in some other 
protocols; it is transmitted in-stream, but with a pointer to indicate 
where it is."</p>
<p>I asked Andrew something to the effect of "<b>What promises does TCP
make about when it will get around to writing data to the network?</b>"  I
thought his reply should be put under this question:</p>
<p>Not many promises, but some.</p>
<p>I'll try and quote chapter and verse on this:</p>
<p><b>References:</b></p>
<p>
</p><blockquote>
RFC 1122, "Requirements for Internet Hosts" (also STD 3)<br>
RFC  793, "Transmission Control Protocol"   (also STD 7)
</blockquote>
<p></p>
<p>
</p><ol>
<li>The socket interface does not provide access to the TCP PUSH flag.</li>
<li>RFC1122 says (4.2.2.2):

A TCP MAY implement PUSH flags on SEND calls.  If PUSH flags
are not implemented, then the sending TCP: (1) must not
buffer data indefinitely, and (2) MUST set the PSH bit in
the last buffered segment (i.e., when there is no more
queued data to be sent).
</li>
<li>RFC793 says (2.8):

When a receiving TCP sees the PUSH flag, it must not wait for
more data from the sending TCP before passing the data to the
receiving process.

[RFC1122 supports this statement.]</li>
<li>Therefore, data passed to a <code>write()</code> call must be delivered to
the peer within a finite time, unless prevented by protocol
considerations.
</li>
<li>There are (according to a post from Stevens quoted in the FAQ 
[earlier in this answer - Vic]) about 11 tests made which could 
delay sending 
the data. But as I see it, there are only 2 that are significant, since
things like retransmit backoff are a) not under the programmers
control and b) must either resolve within a finite time or
drop the connection.</li>
</ol>
<p></p>
<p>The first of the interesting cases is "window closed"  (ie. there is no 
buffer space at the receiver;
this can delay data indefinitely, but only if the receiving
process is not actually reading the data that is available)</p>
<p>Vic asks:</p>
<p><b>OK, it makes sense that if the client isn't reading, the data isn't going
to make it across the connection.  I take it this causes the sender to
block after the recieve queue is filled?</b></p>
<p>The sender blocks when the socket send buffer is full, so buffers
will be full at both ends.</p>
<p>While the window is closed, the sending TCP sends window probe
packets. This ensures that when the window finally does open again,
the sending TCP detects the fact. [RFC1122, ss 4.2.2.17]</p>
<p>The second interesting case is "Nagle algorithm" (small segments, e.g. 
keystrokes, are delayed to
form larger segments if ACKs are expected from the peer; this
is what is disabled with <code>TCP_NODELAY</code>)</p>
<p>Vic Asks:</p>
<p><b>Does this mean that my tcpclient sample should set TCP_NODELAY to ensure
that the end-of-line code is indeed put out onto the network when sent?</b></p>
<p>No. tcpclient.c is doing the right thing as it stands; trying to write
as much data as possible in as few calls to <code>write()</code> as is feasible.
Since the amount of data is likely to be small relative to the socket
send buffer, then it is likely (since the connection is idle at that
point) that the entire request will require only one call to <code>write()</code>,
and that the TCP layer will immediately dispatch the request as a
single segment (with the PSH flag, see point 2.2 above).</p>
<p>The Nagle algorithm only has an effect when a second <code>write()</code> call is
made while data is still unacknowledged. In the normal case, this data
will be left buffered until either: a) there is no unacknowledged data;
or b) enough data is available to dispatch a full-sized segment. The
delay cannot be indefinite, since condition (a) must become true within
the retransmit timeout or the connection dies.</p>
<p>Since this delay has negative consequences for certain applications,
generally those where a stream of small requests are being sent without
response, e.g. mouse movements, the standards specify that an option
must exist to disable it. [RFC1122, ss 4.2.3.4]</p>
<p>Additional note: RFC1122 also says:</p>
<p>
</p><dl>
<dt><b>[DISCUSSION]:</b></dt><dd><p>When the PUSH flag is not implemented on SEND calls,
i.e., when the application/TCP interface uses a pure
streaming model, responsibility for aggregating any
tiny data fragments to form reasonable sized segments
is partially borne by the application layer.</p>
</dd></dl>
<p></p>
<p>So programs should avoid calls to <code>write()</code> with small data lengths
(small relative to the MSS, that is); it's better to build up a
request in a buffer and then do one call to <code>sock_write()</code> or 
equivalent.</p>
<p>The other possible sources of delay in the TCP are not really
controllable by the program, but they can only delay the data
temporarily.</p>
<p> 
Vic asks:</p>
<p><b>By temporarily, you mean that the data will go as soon as it can, and I
won't get stuck in a position where one side is waiting on a response,
and the other side hasn't recieved the request?  (Or at least I won't
get  stuck forever)</b> </p>
<p>You can only deadlock if you somehow manage to fill up all the buffers
in both directions... not easy.</p>
<p>If it is possible to do this, (can't think of a good example though),
the solution is to use nonblocking mode, especially for writes. Then
you can buffer excess data in the program as necessary.

</p><p>
</p><p>
<a name="faq18"><b>12. Where can I get a library for programming sockets?</b></a></p><p><a name="faq18">
There is the Simple Sockets Library by Charles E. Campbell, Jr. PhD. and
Terry McRoberts.  The file is called 
</a><a href="https://web.archive.org/web/20090418145854/http://www.ibrado.com/sock-faq/ssl.tar.gz">ssl.tar.gz</a>, and you can download it
from this faq's home page.  For c++ there is the Socket++ library which is
on 
<a href="https://web.archive.org/web/20090418145854/ftp://ftp.virginia.edu/pub/socket++-1.11.tar.gz">ftp://ftp.virginia.edu/pub/socket++-1.11.tar.gz</a>.  There is 
also C++
Wrappers.  The file is called
<a href="https://web.archive.org/web/20090418145854/ftp://ftp.huji.ac.il/pub/languages/C++/C++_wrappers.2.4.tar.gz">ftp://ftp.huji.ac.il/pub/languages/C++/C++_wrappers.tar.gz</a>.
Thanks to Bill McKinnon for tracking it down for me!  
From 
<a href="https://web.archive.org/web/20090418145854/http://www.cs.wustl.edu/~schmidt">http://www.cs.wustl.edu/~schmidt</a>
you should be able to find the ACE toolkit. 
Another C++ library called libtcp++ is also available at
<a href="https://web.archive.org/web/20090418145854/http://www.sashanet.com/internet/download.html">http://www.sashanet.com/internet/download.html</a>.
PING Software Group has some libraries that include a sockets interface 
among other things.  It seems to be all Java stuff now.  You can find their stuff at <a href="https://web.archive.org/web/20090418145854/http://www.dystance.net/ping/pingutil/index.html">http://www.dystance.net/ping/pingutil/index.html</a>.  Thanks to Jim Kassabian for hunting that down for us (again)!</p>
<p>
<a href="https://web.archive.org/web/20090418145854/mailto:ph.jounin@computer.org">Philippe Jounin <ph.jounin@computer.org></ph.jounin@computer.org></a> has developed a
cross platform library which includes high level support for http and
ftp protocols, with more to come.  You can find it at
<a href="https://web.archive.org/web/20090418145854/http://perso.magic.fr/jounin-ph/P_tcp4u.htm">http://perso.magic.fr/jounin-ph/P_tcp4u.htm</a>, and you
can find a review of it at
<a href="https://web.archive.org/web/20090418145854/http://www6.zdnet.com/cgi-bin/texis/swlib/hotfiles/info.html?fcode=000H4F">http://www6.zdnet.com/cgi-bin/texis/swlib/hotfiles/info.html?fcode=000H4F</a></p>
<p>I don't have any experience with any of these libraries, so I can't 
recomend one over the other.</p><p>
</p><p>
<a name="faq19"><b>13. How come select says there is data, but read returns zero?</b></a></p><p><a name="faq19">

The data that causes select to return is the EOF because the other side
has closed the connection.  This causes read to return zero.  For more
information see 
</a><a data-savepage-href="detail.php3?id=8" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=8">2.1 How can I tell when a socket is closed on the other end?</a></p><p>
</p><p>
<a name="faq20"><b>14. Whats the difference between select() and poll()?</b></a></p><p><a name="faq20">
From Richard Stevens:</a></p><a name="faq20">
<p>The basic difference is that <code>select()</code>'s <code>fd_set</code> is a bit mask and 
therefore
has some fixed size.  It would be possible for the kernel to not limit
this size when the kernel is compiled, allowing the application to define
<code>FD_SETSIZE</code> to whatever it wants (as the comments in the system header
imply today) but it takes more work.  4.4BSD's kernel and the Solaris
library function both have this limit.  But I see that BSD/OS 2.1 has
now been coded to avoid this limit, so it's doable, just a small matter
of programming. :-)  Someone should file a Solaris bug report on this,
and see if it ever gets fixed. <i>[Ed. Note - This was fixed in Solaris 7 - see below.]</i></p>
<p>With <code>poll()</code>, however, the user must allocate an array of <code>pollfd</code> 
structures,
and pass the number of entries in this array, so there's no fundamental
limit.  As Casper notes, fewer systems have <code>poll()</code> than <code>select</code>, so 
the latter
is more portable.  Also, with original implementations (SVR3) you could not
set the descriptor to -1 to tell the kernel to ignore an entry in the 
<code>pollfd</code>
structure, which made it hard to remove entries from the array; SVR4 gets
around this.  Personally, I always use <code>select()</code> and rarely <code>poll()</code>, 
because I
port my code to BSD environments too.  Someone could write an implementation
of <code>poll()</code> that uses <code>select()</code>, for these environments, but I've 
never 
seen one. Both <code>select()</code> and <code>poll()</code> are being standardized by POSIX 
1003.1g.
</p></a><p><a name="faq20">
Colm Smyth (</a><a href="https://web.archive.org/web/20090418145854/mailto:Colm.Smyth@Sun.COM">Colm.Smyth@Sun.COM</a>) writes:</p><p>
I thought you might be interested to know that this was
resolved in Solaris 7; here is an extract from the select(3C)
man-page:
</p><p>
NOTES
</p><blockquote>
     The default value for FD_SETSIZE (currently 1024) is  larger
     than  the  default  limit  on  the  number of open files. To
     accommodate 32-bit applications that  wish to use  a  larger
     number  of  open  files  with  select(),  it  is possible to
     increase this size at compile time  by  providing  a  larger
     definition   of   FD_SETSIZE   before   the   inclusion   of
     <sys types.h="">. The maximum supported size for FD_SETSIZE  is
     65536.  The default value is already 65536 for 64-bit applications.
</sys></blockquote><p>
</p><p>
<a name="faq21"><b>15. How do I send [this] over a socket</b></a></p><p><a name="faq21">


Anything other than single bytes of data will probably get mangled unless 
you take care.  For integer values you can use <code>htons()</code> and friends, and 
strings are really just a bunch of single bytes, so those should be OK.  
Be careful not to send a pointer to a string though, since the pointer 
will be meaningless on another machine.  If you need to send a struct, 
you should write <code>sendthisstruct()</code> and <code>readthisstruct()</code> functions 
for it 
that do all the work of taking the structure apart on one side, and 
putting it back together on the other.  If you need to send floats, you 
may have a lot of work ahead of you.  You should read RFC 1014 which is 
about portable ways of getting data from one machine to another (thanks 
to Andrew Gabriel for pointing this out).</a></p><p><a name="faq21">
</a></p><p><a name="faq21">
</a><a name="faq22"><b>16. How do I use TCP_NODELAY?</b></a></p><p><a name="faq22">

First off, be sure you really want to use it in the first place.  It will 
disable the Nagle algorithm 
(see 
</a><a data-savepage-href="detail.php3?id=17" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=17">2.11 How can I force a socket to send the data in its buffer?</a>),
which will cause network traffic 
to increase, with smaller than needed packets wasting bandwidth.  Also, 
from what I have been able to tell, the speed increase is very small, so 
you should probably do it without <code>TCP_NODELAY</code> first, and only turn 
it on if there is a problem.</p>
<p>Here is a code example, with a warning about using it from Andrew Gierth: </p>
<p>
</p><blockquote><code>
<pre>  int flag = 1;
  int result = setsockopt(sock,            /* socket affected */
                          IPPROTO_TCP,     /* set option at TCP level */
                          TCP_NODELAY,     /* name of option */
                          (char *) &amp;flag;,  /* the cast is historical 
                                                  cruft */
                          sizeof(int));    /* length of option value */
  if (result &lt; 0)
     ... handle the error ...
</pre>
</code></blockquote>
 <p></p>
<p><code>TCP_NODELAY</code> is for a <em>specific</em> purpose; to disable the Nagle 
buffering
algorithm. It should only be set for applications that send frequent
small bursts of information without getting an immediate response, where
timely delivery of data is required (the canonical example is mouse
movements).</p><p>
</p><p>
<a name="faq23"><b>17. What exactly does the Nagle algorithm do?</b></a></p><p><a name="faq23">
It groups together as much data as it can between ACK's from the other end
of the connection.  I found this really confusing until Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>)
drew the following diagram, and explained: </p>
<p>This diagram is not intended to be complete, just to illustrate
the point better...</p>
<p><b>Case 1</b>: client writes 1 byte per <code>write()</code> call. The program on
host B is tcpserver.c from the FAQ examples.</p>
<p>
</p><blockquote><code>
<pre>      CLIENT                                  SERVER
APP             TCP                     TCP             APP
                [connection setup omitted]

 "h" ---------&gt;          [1 byte]
                    ------------------&gt;
                                           -----------&gt; "h"
                                   [ack delayed]
 "e" ---------&gt; [Nagle alg.              .
                 now in effect]          .
 "l" ---------&gt; [ditto]                  .
 "l" ---------&gt; [ditto]                  .
 "o" ---------&gt; [ditto]                  .
 "\n"---------&gt; [ditto]                  .
                                         .
                                         .
                       [ack 1 byte]
                    &lt;------------------
                [send queued
                data]
                        [5 bytes]
                    ------------------&gt;
                                          ------------&gt; "ello\n"
                                          &lt;------------ "HELLO\n"
                   [6 bytes, ack 5 bytes]
                    &lt;------------------
 "HELLO\n" &lt;----
              [ack delayed]
                 .
                 .
                 .   [ack 6 bytes]
                    ------------------&gt;
</pre>
</code></blockquote>
<p></p>
<p>Total segments: 5. (If <code>TCP_NODELAY</code> was set, could have been up to 10.)
Time for response: 2*RTT, plus ack delay.</p>
<p><b>Case 2</b>: client writes all data with one <code>write()</code> call.</p>
<p>
</p><blockquote><code>
<pre>      CLIENT                                  SERVER
APP             TCP                     TCP             APP
                [connection setup omitted]

 "hello\n" ---&gt;          [6 bytes]
                    ------------------&gt;
                                          ------------&gt; "hello\n"
                                          &lt;------------ "HELLO\n"
                   [6 bytes, ack 6 bytes]
                    &lt;------------------
 "HELLO\n" &lt;----
            [ack delayed]
                 .
                 .
                 .   [ack 6 bytes]
                    ------------------&gt;
</pre>
</code></blockquote>
<p></p>
<p>Total segments: 3.</p>
<p>Time for response = RTT (therefore minimum possible).</p>
<p>Hope this makes things a bit clearer...</p>
<p>Note that in case 2, you <em>don't</em> want the implementation to gratuitously
delay sending the data, since that would add straight onto the response
time.</p><p>
</p><p>
<a name="faq24"><b>18. What is the difference between read() and recv()?</b></a></p><p><a name="faq24">

From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p><code>read()</code> is equivalent to <code>recv()</code> with a <code>flags</code> parameter of 0. 
Other values
for the <code>flags</code> parameter change the behaviour of <code>recv()</code>. Similarly, 
<code>write()</code> is equivalent to <code>send()</code> with <code>flags</code> == 0. </p>
<p>It is unlikely that send()/recv() would be dropped; perhaps someone with a
copy of the POSIX drafts for socket calls can check... </p>
<p>Portability note: non-unix systems may not allow <code>read()/write()</code> on
sockets, but <code>recv()/send()</code> are usually ok. This is true on 
Windows and OS/2, for example.</p><p>
</p><p>
<a name="faq25"><b>19. I see that send()/write() can generate SIGPIPE. Is there any advantage to handling the signal, rather than just ignoring it and checking for the EPIPE error?</b></a></p><p><a name="faq25">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>In general, the only parameter passed to a signal handler is the signal
number that caused it to be invoked.  Some systems have optional additional
parameters, but they are no use to you in this case. </p>
<p>My advice is to just ignore <code>SIGPIPE</code> as you suggest. That's what I do in
just about all of my socket code; errno values are easier to handle than
signals (in fact, the first revision of the FAQ failed to mention 
<code>SIGPIPE</code> in that context; I'd got so used to ignoring it...)</p>
<p>There is one situation where you should <em>not</em> ignore <code>SIGPIPE</code>; if 
you are
going to <code>exec()</code> another program with stdout redirected to a socket. In
this case it is probably wise to set <code>SIGPIPE</code> to <code>SIG_DFL</code> before 
doing the <code>exec()</code>.
</p><p>
<a href="https://web.archive.org/web/20090418145854/mailto:jesse@kci.net">Jesse Norell</a> has
pointed out that if you are using SO_KEEPALIVE to test the
connection, and you aren't doing reads or writes very
frequently, you might want to leave SIGPIPE enabled so
that your server process gets signalled when the system
determines your link is dead.  Normally though you will
just check returns from <code>read()/write()</code> and act appropriately.</p><p>
</p><p>
<a name="faq26"><b>20. After the chroot(), calls to socket() are failing.  Why?</b></a></p><p><a name="faq26">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>On systems where sockets are implemented on top of Streams (e.g. all
SysV-based systems, presumably including Solaris), the <code>socket()</code> function
will actually be opening certain special files in /dev. You will need to
create a /dev directory under your fake root and populate it with the
required device nodes (only). </p>
<p>Your system documentation may or may not specify exactly which device
nodes are required; I can't help you there (sorry).  (Editors note:  
Adrian Hall
(<a href="https://web.archive.org/web/20090418145854/mailto:adrian@hottub.org">adrian@hottub.org</a>) suggested checking the man page for 
ftpd, which should list the files you need to copy and devices you need 
to create in the chroot'd environment.)</p>
<p>A less-obvious issue with <code>chroot()</code> is if you call <code>syslog()</code>, as many
daemons do; <code>syslog()</code> opens (depending on the system) either a UDP
socket, a FIFO or a Unix-domain socket. So if you use it after a
<code>chroot()</code> call, make sure that you call <code>openlog()</code> *before* the 
chroot.</p><p>
</p><p>
<a name="faq27"><b>21. Why do I keep getting EINTR from the socket calls?</b></a></p><p><a name="faq27">

This isn't really so much an error as an exit condition.  It means that 
the call was interrupted by a signal.  Any call that might block should 
be wrapped in a loop that checkes for <code>EINTR</code>, as is done in the example 
code (See 
</a><a data-savepage-href="detail.php3?id=65" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=65">1.8. Sample Source Code</a>).</p><p>
</p><p>
<a name="faq28"><b>22. When will my application receive SIGPIPE?</b></a></p><p><a name="faq28">
From Richard Stevens 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:rstevens@noao.edu">rstevens@noao.edu</a>):</p>
<p>Very simple: with TCP you get <code>SIGPIPE</code> if your end of the connection
has received an RST from the other end.  What this also means is that
if you were using <code>select</code> instead of write, the select would have
indicated the socket as being readable, since the RST is there for
you to read (read will return an error with <code>errno</code> set to 
<code>ECONNRESET</code>).</p>
<p>Basically an RST is TCP's response to some packet that it doesn't expect
and has no other way of dealing with.  A common case is when the peer closes
the connection (sending you a FIN) but you ignore it because you're writing
and not reading.  (You should be using <code>select</code>.)  So you write to a 
connection
that has been closed by the other end and the other end's TCP responds with
an RST.</p><p>
</p><p>
<a name="faq29"><b>23. What are socket exceptions?  What is out-of-band data?</b></a></p><p><a name="faq29">


Unlike exceptions in C++, socket exceptions do not indicate that an error 
has occured.  Socket exceptions usually refer to the notification 
that out-of-band data has arrived.  Out-of-band data (called "urgent 
data" in TCP) looks to the application like a separate stream of data 
from the main data stream.  This can be useful for separating two 
different kinds of data.  Note that just because it is called "urgent 
data" does not mean that it will be delivered any faster, or with higher 
priorety than data in the in-band data stream.  Also beware that unlike 
the main data stream, the out-of-bound data may be lost if your 
application can't keep up with it.</a></p><p><a name="faq29">
</a></p><p><a name="faq29">
</a><a name="faq30"><b>24. How can I find the full hostname (FQDN) of the system I'm running on?</b></a></p><p><a name="faq30">
From Richard Stevens 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:rstevens@noao.edu">rstevens@noao.edu</a>):</p>
<p>Some systems set the hostname to the FQDN and others set it to just
the unqualified host name.  I know the current BIND FAQ recommends the
FQDN, but most Solaris systems, for example, tend to use only the
unqualified host name.</p>
<p>Regardless, the way around this is to first get the host's name (perhaps
an FQDN, perhaps unaualified).  Most systems support the Posix way to do
this using <code>uname()</code>, but older BSD systems only provide 
<code>gethostname()</code>.
Call <code>gethostbyname()</code> to find your IP address.  Then take the IP address
and call <code>gethostbyaddr()</code>.  The <code>h_name</code> member of the <code>hostent{}</code>
should
then be your FQDN.</p><p>
</p><p>
<a name="faq83"><b>25. How do I monitor the activity of sockets?</b></a></p><p><a name="faq83">
From: Matthias Rabast (</a><a href="https://web.archive.org/web/20090418145854/mailto:matthias.rabast@ubs.com">matthias.rabast@ubs.com</a>)
</p><p>
How can I find out,</p><ul>
<li>which sockets have highest throughput ?
</li><li>how big is the tcp window size for each socket ?
</li><li>how often does a special socket block and go again ?
</li></ul>
<p>
For monitoring throughput there are tools such as <a href="https://web.archive.org/web/20090418145854/http://www.sp.uconn.edu/~jrifkin/ipaudit/">IPAudit</a> that will monitor throughput.  I can't remember which tool I used to use for this purpose, but a quick search found IPAudit.  I haven't tried it, so let me know if it works, or if you know some better tools.
</p><p>
You can use <tt>netstat -a</tt> under solaris and look at the Swind and Rwind columns for send and recieve window sizes.
</p><p>
I'm not aware of any tools for monitoring how often a socket blocks.  Someone please add a comment if you have any suggestions for this.
</p><p>
You could parse the output of snoop/tcpdump to get some of this information.  Let me know if you know a good parser and I'll list it here.</p><p>
</p><p>
</p><h3>3. Writing Client Applications (TCP/SOCK_STREAM)</h3>
<a name="faq32"><b>1. How do I convert a string into an internet address?</b><p>


If you are reading a host's address from the command line, you may not 
know if you have an aaa.bbb.ccc.ddd style address, or a host.domain.com 
style address.  What I do with these, is first try to use it as a 
aaa.bbb.ccc.ddd type address, and if that fails, then do a name lookup on 
it.  Here is an example:</p>
<p>
</p><blockquote><code>
<pre>/* Converts ascii text to in_addr struct.  NULL is returned if the 
   address can not be found. */
struct in_addr *atoaddr(char *address) {
  struct hostent *host;
  static struct in_addr saddr;

  /* First try it as aaa.bbb.ccc.ddd. */
  saddr.s_addr = inet_addr(address);
  if (saddr.s_addr != -1) {
    return &amp;saddr;
  }
  host = gethostbyname(address);
  if (host != NULL) {
    return (struct in_addr *) *host-&gt;h_addr_list;
  }
  return NULL;
}
</pre>
</code></blockquote><p>
</p></a><p><a name="faq32">
</a><a name="faq33"><b>2. How can my client work through a firewall/proxy server?</b></a></p><p><a name="faq33">
If you are running through separate proxies for each service, you 
shouldn't
need to do anything.  If you are working through sockd, you will need to
"socksify" your application.  Details for doing this can be found in the
package itself, which is available at:</a></p><a name="faq33">
<p>
</p></a><blockquote><a name="faq33">
</a><a href="https://web.archive.org/web/20090418145854/ftp://coast.cs.purdue.edu/pub/tools/unix/socks/FAQ">ftp://coast.cs.purdue.edu/pub/tools/unix/socks/</a></blockquote><p>
</p><p>
<a name="faq34"><b>3. Why does connect() succeed even before my server did an accept()?</b></a></p><p><a name="faq34">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>Once you have done a <code>listen()</code> call on your socket, the kernel is 
primed to
accept connections on it. The usual UNIX implementation of this works by
<em>immediately</em> completing the SYN handshake for any incoming valid SYN
segments (connection attempts), creating the socket for the new connection,
and keeping this new socket on an internal queue ready for the <code>accept()</code>
call. So the socket is fully open <em>before</em> the accept is done.</p>
<p>The other factor in this is the 'backlog' parameter for <code>listen()</code>; that
defines how many of these completed connections can be queued at one time.
If the specified number is exceeded, then new incoming connects are simply
ignored (which causes them to be retried).</p><p>
</p><p>
<a name="faq35"><b>4. Why do I sometimes lose a server's address when using more than one server?</b></a></p><p><a name="faq35">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>Take a careful look at struct hostent. Notice that almost everything
in it is a pointer? <em>All</em> these pointers will refer to statically
allocated data.</p>
<p>For example, if you do:</p>
<p>
</p><blockquote><code>
<pre>    struct hostent *host = gethostbyname(hostname);
</pre>
</code></blockquote>
<p></p>
<p>then (as you should know) a subsequent call to <code>gethostbyname()</code> will
overwrite the structure pointed to by 'host'.</p>
<p>But if you do:</p>
<p>
</p><blockquote><code>
<pre>    struct hostent myhost;
    struct hostent *hostptr = gethostbyname(hostname);
    if (hostptr) myhost = *host;
</pre>
</code></blockquote>
<p></p>
<p>to make a copy of the <code>hostent</code> before it gets overwritten, then it 
<em>still</em>
gets clobbered by a subsequent call to <code>gethostbyname()</code>, since although
<code>myhost</code> won't get overwritten, all the data it is pointing to 
will be. </p>
<p>You can get round this by doing a proper 'deep copy' of the <code>hostent</code>
structure, but this is tedious. My recommendation would be to extract
the needed fields of the <code>hostent</code> and store them in your own way.</p>
<p>Robin Paterson
(<a href="https://web.archive.org/web/20090418145854/mailto:etmrpat@etm.ericsson.se">etmrpat@etm.ericsson.se</a>) has added:</p>
<p>It might be nice if you mention MT safe libraries provide complimentary 
functions for multithreaded programming.  On the solaris machine 
I'm typing at, we have <code>gethostbyname</code> and <code>gethostbyname_r</code>
(<code>_r</code> for reentrant).
The main difference is, <em>you</em> provide the storage for the hostent 
struct so you always have a local copy and not just a pointer to the 
static copy.</p><p>
</p><p>
<a name="faq36"><b>5. How can I set the timeout for the connect() system call?</b></a></p><p><a name="faq36">
From Richard Stevens 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:rstevens@noao.edu">rstevens@noao.edu</a>):</p>
<p>Normally you cannot change this.  Solaris does let you do this, on a
per-kernel basis with the ndd <code>tcp_ip_abort_cinterval</code> parameter.</p>
<p>The easiest way to shorten the connect time is with an <code>alarm()</code> around
the call to <code>connect()</code>.  A harder way is to use <code>select()</code>, after 
setting the socket nonblocking.  Also notice that you can only shorten the
connect time, there's normally no way to lengthen it.</p>
<p>From Andrew Gierth 
(<a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>First, create the socket and put it into non-blocking mode, then call
connect(). There are three possibilities:</p>
<p>
</p><ul>
<li>connect succeeds: the connection has been successfully made (this
usually only happens when connecting to the same machine)</li>
<li>connect fails: obvious</li>
<li>connect returns -1/EINPROGRESS. The connection attempt has begun,
but not yet completed.</li>
</ul>
<p></p>
<p>If the connection succeeds:</p>
<p>
</p><ul>
<li>the socket will select() as writable (and will also select as readable
if data arrives)</li>
</ul>
<p></p>
<p>If the connection fails:</p>
<p>
</p><ul>
<li>the socket will select as readable *and* writable, but either a read 
or write will return the error code from the connection attempt. Also,
you can use getsockopt(SO_ERROR) to get the error status - but be 
careful; some systems return the error code in the result parameter of 
getsockopt, but others (incorrectly) cause the getsockopt call *itself*
to fail with the stored value as the error.</li>
</ul><p>
</p><p>
<a name="faq37"><b>6. Should I bind() a port number in my client program, or let the system choose one for me on the connect() call?</b></a></p><p><a name="faq37">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p><b>** Let the system choose your client's port number **</b></p>
<p>The exception to this, is if the server has been written to be picky about
what client ports it will allow connections from. Rlogind and rshd are the
classic examples. This is usually part of a Unix-specific (and rather weak)
authentication scheme; the intent is that the server allows connections only
from processes with root privilege. (The weakness in the scheme is that many
O/Ss (e.g. MS-DOS) allow anyone to bind any port.)</p>
<p>The <code>rresvport()</code> routine exists to help out clients that are using this
scheme. It basically does the equivalent of <code>socket()</code> + <code>bind()</code>, 
choosing a port number in the range 512..1023.</p>
<p>If the server is not fussy about the <em>client's</em> port number, then 
don't try
and assign it yourself in the client, just let <code>connect()</code> pick it for 
you.</p>
<p>If, in a client, you use the naive scheme of starting at a fixed port number
and calling <code>bind()</code> on consecutive values until it works, then you buy
yourself a whole lot of trouble:</p>
<p>The problem is if the server end of your connection does an active close.
(E.G. client sends 'QUIT' command to server, server responds by closing the
connection). That leaves the client end of the connection in CLOSED state,
and the server end in TIME_WAIT state. So after the client exits, there is
no trace of the connection on the client end.</p>
<p>Now run the client again. It will pick the same port number, since as far as
it can see, it's free. But as soon as it calls <code>connect()</code>, the server 
finds
that you are trying to duplicate an existing connection (although one in
TIME_WAIT). It is perfectly entitled to refuse to do this, so you get, I
suspect, <code>ECONNREFUSED</code> from <code>connect()</code>. (Some systems may sometimes 
allow the connection anyway, but you <em>can't</em> rely on it.)</p>
<p>This problem is <em>especially</em> dangerous because it doesn't show up 
unless the
client and server are on <em>different</em> machines. (If they are the same 
machine,
then the client <em>won't</em> pick the same port number as before). So you 
can get
bitten well into the development cycle (if you do what I suspect most people
do, and test client &amp; server on the same box initially).</p>
<p>Even if your protocol has the client closing first, there are still ways to
produce this problem (e.g. kill the server).</p><p>
</p><p>
<a name="faq38"><b>7. Why do I get "connection refused" when the server isn't running?</b></a></p><p><a name="faq38">
The <code>connect()</code> call will only block while it is waiting to establish a
connection.  When there is no server waiting at the other end, it gets
notified that the connection can not be established, and gives up with the
error message you see.  This is a good thing, since if it were not the
case clients might wait for ever for a service which just doesn't exist. 
Users would think that they were only waiting for the connection to be
established, and then after a while give up, muttering something about
crummy software under their breath.</a></p><p><a name="faq38">
</a></p><p><a name="faq38">
</a><a name="faq39"><b>8. What does one do when one does not know how much information is comming over the socket?  Is there a way to have a dynamic buffer?</b></a></p><p><a name="faq39">
This question asked by Niranjan Perera
(</a><a href="https://web.archive.org/web/20090418145854/mailto:perera@mindspring.com">perera@mindspring.com</a>).</p>
<p>When the size of the incoming data is unknown, you can either make the
size of the buffer as big as the largest possible (or likely) buffer, or
you can re-size the buffer on the fly during your read.  When you 
<code>malloc()</code>
a large buffer, most (if not all) varients of unix will only allocate
address space, but not physical pages of ram.  As more and more of the
buffer is used, the kernel allocates physical memory.  This means that
malloc'ing a large buffer will not waste resources unless that memory is
used, and so it is perfectly acceptable to ask for a meg of ram when you
expect only a few K.</p>
<p>On the other hand, a more elegant solution that does not depend on the
inner workings of the kernel is to use realloc() to expand the buffer as
required in say 4K chunks (since 4K is the size of a page of ram on most
systems).  I may add something like this to sockhelp.c in the example
code one day.</p><p>
</p><p>
<a name="faq82"><b>9. How can I determine the local port number?</b></a></p><p><a name="faq82">
From: Fajun Shi 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:fajun@cs.msstate.edu">fajun@cs.msstate.edu</a>):
</p><p>
Hi, my question is: When I write a client, how can I know the 
port number that the socket bound in my machine?
</p><p>
</p><p>
</p><h3>4. Writing Server Applications (TCP/SOCK_STREAM)</h3>
<a name="faq40"><b>1. How come I get "address already in use" from bind()?</b></a><p><a name="faq40">
You get this when the address is already in use.  (Oh, you figured that 
much out?)  The most common reason for this is that you have stopped your 
server, and then re-started it right away.  The sockets that were used by 
the first incarnation of the server are still active.  This is further 
explained in 
</a><a data-savepage-href="detail.php3?id=13" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=13">2.7 Please explain the TIME_WAIT state.</a>, and
<a data-savepage-href="detail.php3?id=31" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=31">2.5 How do I properly close a socket?</a>.</p><p>
</p><p>
<a name="faq41"><b>2. Why don't my sockets close?</b></a></p><p><a name="faq41">

When you issue the <code>close()</code> system call, you are closing your 
interface to 
the socket, not the socket itself.  It is up to the kernel to close the 
socket.  Sometimes, for really technical reasons, the socket is kept 
alive for a few minutes after you close it.  It is normal, for example 
for the socket to go into a TIME_WAIT state, on the server side, for a 
few minutes.  People have reported ranges from 20 seconds to 4 minutes 
to me.  The official standard says that it should be 4 minutes.  On my 
Linux system it is about 2 minutes.  This is explained in great detail in 
</a><a data-savepage-href="detail.php3?id=13" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=13">2.7 Please explain the TIME_WAIT state.</a>.</p><p>
</p><p>
<a name="faq42"><b>3. How can I make my server a daemon?</b></a></p><p><a name="faq42">
There are two approaches you can take here.  The first is to use inetd to 
do all the hard work for you.  The second is to do all the hard work 
yourself.</a></p><a name="faq42">
<p>If you use inetd, you simply use <code>stdin</code>, <code>stdout</code>, or <code>stderr</code> for 
your 
socket.  (These three are all created with <code>dup()</code> from the real socket)  
You can use these as you would a socket in your code.  The inetd process 
will even close the socket for you when you are done.  For more information on setting this up, look at the man page for inetd.</p>
</a><p><a name="faq42">If you wish to write your own server, there is a detailed explanation in 
"Unix Network Programming" by Richard Stevens (see
</a><a data-savepage-href="detail.php3?id=6" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=6">1.6 Where can I get source code for the book [book  title]?</a>). I also 
picked up this 
posting from comp.unix.programmer, by Nikhil Nair 
(<a href="https://web.archive.org/web/20090418145854/mailto:nn201@cus.cam.ac.uk">nn201@cus.cam.ac.uk</a>).
You may want to add code to ignore SIGPIPE, because if this signal is
not dealt with, it will cause your application to exit.  (Thanks to
<a href="https://web.archive.org/web/20090418145854/mailto:ingo@milan2.snafu.de">ingo@milan2.snafu.de</a>
for pointing this out).</p>
<p>
</p><blockquote><code>
<pre>I worked all this lot out from the GNU C Library Manual (on-line
documentation).  Here's some code I wrote - you can adapt it as necessary:


#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include <sys wait.h="">

/* Global variables */
...
volatile sig_atomic_t keep_going = 1; /* controls program termination */


/* Function prototypes: */
...
void termination_handler (int signum); /* clean up before termination */


int
main (void)
{
  ...

  if (chdir (HOME_DIR))         /* change to directory containing data 
                                    files */
   {
     fprintf (stderr, "`%s': ", HOME_DIR);
     perror (NULL);
     exit (1);
   }

   /* Become a daemon: */
   switch (fork ())
     {
     case -1:                    /* can't fork */
       perror ("fork()");
       exit (3);
     case 0:                     /* child, process becomes a daemon: */
       close (STDIN_FILENO);
       close (STDOUT_FILENO);
       close (STDERR_FILENO);
       if (setsid () == -1)      /* request a new session (job control) */
         {
           exit (4);
         }
       break;
     default:                    /* parent returns to calling process: */
       return 0;
     }

   /* Establish signal handler to clean up before termination: */
   if (signal (SIGTERM, termination_handler) == SIG_IGN)
     signal (SIGTERM, SIG_IGN);
   signal (SIGINT, SIG_IGN);
   signal (SIGHUP, SIG_IGN);

   /* Main program loop */
   while (keep_going)
     {
       ...
     }
   return 0;
}

void
termination_handler (int signum)
{
  keep_going = 0;
  signal (signum, termination_handler);
}
</sys></signal.h></fcntl.h></unistd.h></ctype.h></stdlib.h></stdio.h></pre>
</code></blockquote><p>
</p><p>
<a name="faq43"><b>4. How can I listen on more than one port at a time?</b></a></p><p><a name="faq43">


The best way to do this is with the <code>select()</code> call.  This tells the 
kernel 
to let you know when a socket is available for use.  You can have one 
process do i/o with multiple sockets with this call.  If you want to wait 
for a connect on sockets 4, 6 and 10 you might execute the following code 
snippet:</a></p><a name="faq43">
<p>
</p><blockquote><code>
<pre>fd_set socklist;

FD_ZERO(&amp;socklist); /* Always clear the structure first. */
FD_SET(4, &amp;socklist);
FD_SET(6, &amp;socklist);
FD_SET(10, &amp;socklist);
if (select(11, NULL, &amp;socklist, NULL, NULL) &lt; 0)
  perror("select");
</pre>
</code></blockquote>
<p></p>
<p>The kernel will notify us as soon as a file descriptor which is less than 
11 (the first parameter to <code>select()</code>), and is a member of our 
<code>socklist</code> becomes 
available for writing.  See the man page on <code>select()</code> for more details.</p>

<p>
</p></a><p><a name="faq43">
</a><a name="faq44"><b>5. What exactly does SO_REUSEADDR do?</b></a></p><p><a name="faq44">

This socket option tells the kernel that even if this port is busy (in
the TIME_WAIT state), go ahead and reuse it anyway.  If it is busy, but 
with another state, you will still get an address already in use error.
It is useful if your server has been shut down, and then restarted right 
away while sockets are still active on its port.  You should be aware 
that if any unexpected data comes in, it may confuse your server, but 
while this is possible, it is not likely. </a></p><a name="faq44">
</a><p><a name="faq44">It has been pointed out that "A socket is a 5 tuple (proto, local addr,
local port, remote addr, remote port).  SO_REUSEADDR just says that you
can reuse local addresses.  The 5 tuple still must be unique!" by Michael 
Hunter (mphunter@qnx.com).  This is true, and this is why it is very 
unlikely that unexpected data will ever be seen by your server.  The 
danger is that such a 5 tuple is still floating around on the net, and 
while it is bouncing around, a new connection from the same client, on 
the same system, happens to get the same remote port.  This is explained 
by Richard Stevens in 
</a><a data-savepage-href="detail.php3?id=13" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=13">2.7 Please explain the TIME_WAIT state.</a>.</p>

<p>
</p><p>
<a name="faq45"><b>6. What exactly does SO_LINGER do?</b></a></p><p><a name="faq45">
On some unixes this does nothing.  On others, it instructs the kernel to 
abort tcp connections instead of closing them properly.  This can be 
dangerous.  If you are not clear on this, see 
</a><a data-savepage-href="detail.php3?id=13" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=13">2.7 Please explain the TIME_WAIT state.</a>.</p>

<p>
</p><p>
<a name="faq46"><b>7. What exactly does SO_KEEPALIVE do?</b></a></p><p><a name="faq46">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>The <code>SO_KEEPALIVE</code> option causes a packet (called a 'keepalive probe') 
to be
sent to the remote system if a long time (by default, more than 2 hours)
passes with no other data being sent or received. This packet is designed to
provoke an ACK response from the peer. This enables detection of a peer
which has become unreachable (e.g. powered off or disconnected from the net).
See 
<a data-savepage-href="detail.php3?id=14" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=14">2.8 Why does it take so long to detect that the peer died?</a>
for further discussion.</p>
<p>Note that the figure of 2 hours comes from RFC1122, "Requirements for
Internet Hosts". The precise value should be configurable, but I've often
found this to be difficult.  The only implementation I know of that 
allows the keepalive interval to be set per-connection is SVR4.2.</p><p>
</p><p>
<a name="faq47"><b>8. 4.8 How can I bind() to a port number &lt; 1024?</b></a></p><p><a name="faq47">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>The restriction on access to ports &lt; 1024 is part of a (fairly weak)
security scheme particular to UNIX. The intention is that servers (for
example rlogind, rshd) can check the port number of the client, and if it
is &lt; 1024, assume the request has been properly authorised at the client
end.</p>
<p>The practical upshot of this, is that binding a port number &lt; 1024 is
reserved to processes having an effective UID == root.</p>
<p>This can, occasionally, itself present a security problem, e.g. when a
server process needs to bind a well-known port, but does <em>not</em> itself need
root access (news servers, for example). This is often solved by creating
a small program which simply binds the socket, then restores the real userid
and <code>exec()</code>s the real server. This program can then be made setuid root.</p>

<p>
</p><p>
<a name="faq48"><b>9. How do I get my server to find out the client's address / hostname?</b></a></p><p><a name="faq48">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>After <code>accept()</code>ing a connection, use <code>getpeername()</code> to get the
address of the client.
The client's address is of
course, also returned on the <code>accept()</code>, but it is essential to
initialise the address-length parameter before the accept call for this
will work. </p>
<p>Jari Kokko (<a href="https://web.archive.org/web/20090418145854/mailto:jkokko@cc.hut.fi">jkokko@cc.hut.fi</a>)
has offered the following code to determine the client address:</p>
<p>
</p><blockquote><code>
<pre>int t;
int len;
struct sockaddr_in sin;
struct hostent *host;

len = sizeof sin;
if (getpeername(t, (struct sockaddr *) &amp;sin;, &amp;len;) &lt; 0)
        perror("getpeername");
else {
        if ((host = gethostbyaddr((char *) &amp;sin.sin;_addr,
                                  sizeof sin.sin_addr,
                                  AF_INET)) == NULL)
            perror("gethostbyaddr");
        else printf("remote host is '%s'\n", host-&gt;h_name);
}
</pre>
</code></blockquote><p>
</p><p>
<a name="faq49"><b>10. How should I choose a port number for my server?</b></a></p><p><a name="faq49">


The list of registered port assignments can be found in STD 2 or RFC 1700. 
Choose one that isn't already registered, and isn't in /etc/services on
your system.  It is also a good idea to let users customize the port
number in case of conflicts with other un-registered port numbers in other
servers.  The best way of doing this is hardcoding a service name, and 
using <code>getservbyname()</code> to lookup the actual port number.  This method 
allows users to change the port your server binds to by simply editing 
the /etc/services file.</a></p><p><a name="faq49">
</a></p><p><a name="faq49">
</a><a name="faq50"><b>11. What is the difference between SO_REUSEADDR and SO_REUSEPORT?</b></a></p><p><a name="faq50">
<code>SO_REUSEADDR</code> allows your server to bind to an address which is in a
TIME_WAIT state.  It does not allow more than one server to bind to the
same address.  It was mentioned that use of this flag can create a
security risk because another server can bind to a the same port, by
binding to a specific address as opposed to <code>INADDR_ANY</code>.  The 
<code>SO_REUSEPORT</code>
flag allows multiple processes to bind to the same address provided all of
them use the <code>SO_REUSEPORT</code> option.  </a></p><a name="faq50">
</a><p><a name="faq50">From Richard Stevens 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:rstevens@noao.edu">rstevens@noao.edu</a>):</p>
<p>This is a newer flag that appeared in the 4.4BSD multicasting code
(although that code was from elsewhere, so I am not sure just who
invented the new <code>SO_REUSEPORT</code> flag).</p>
<p>What this flag lets you do is rebind a port that is already in use,
but only if all users of the port specify the flag.  I believe the
intent is for multicasting apps, since if you're running the same
app on a host, all need to bind the same port.  But the flag may have
other uses.  For example the following is from a post in February:</p>
<p>From Stu Friedberg 
(<a href="https://web.archive.org/web/20090418145854/mailto:stuartf@sequent.com">stuartf@sequent.com</a>):</p>
<p>
</p><blockquote>
<code>SO_REUSEPORT</code> is also useful for eliminating the try-10-times-to-bind
hack in ftpd's data connection setup routine.  Without <code>SO_REUSEPORT</code>,
only one ftpd thread can bind to TCP (lhost, lport, <code>INADDR_ANY</code>, 0) in
preparation for connecting back to the client.  Under conditions of
heavy load, there are more threads colliding here than the try-10-times
hack can accomodate.  With <code>SO_REUSEPORT</code>, things work nicely and the
hack becomes unnecessary.
</blockquote>
<p></p>
<p>I have also heard that DEC OSF supports the flag.  Also note that under
4.4BSD, if you are binding a multicast address, then <code>SO_REUSEADDR</code> is
condisered the same as <code>SO_REUSEPORT</code> (p. 731 of "TCP/IP Illustrated,
Volume 2").  I think under Solaris you just replace <code>SO_REUSEPORT</code> with
<code>SO_REUSEADDR</code>.</p>
<p>From a later Stevens posting, with minor editing:</p>
<p>Basically <code>SO_REUSEPORT</code> is a BSD'ism that arose when multicasting was added,
even thought it was not used in the original Steve Deering code.  I
believe some BSD-derived systems may also include it (OSF, now Digital
Unix, perhaps?).  <code>SO_REUSEPORT</code> lets you bind the same address *and* port,
but only if all the binders have specified it.  But when binding a
multicast address (its main use), <code>SO_REUSEADDR</code> is considered identical
to <code>SO_REUSEPORT</code> (p. 731, "TCP/IP Illustrated, Volume 2").  
So for portability of multicasting applications
I always use <code>SO_REUSEADDR</code>.</p><p>
</p><p>
<a name="faq51"><b>12. How can I write a multi-homed server?</b></a></p><p><a name="faq51">
The original question was actually from Shankar Ramamoorthy
(</a><a href="https://web.archive.org/web/20090418145854/mailto:shankar@viman.com">shankar@viman.com</a>):</p>
<p>
</p><blockquote>
<em>I want to run a server on a multi-homed host. The host is part of
two networks and has two ethernet cards. I want to run a server on
this machine, binding to a pre-determined port number. I want 
clients on either subnet to be able to send broadcast packates to
the port and have the server receive them.</em>
</blockquote>
<p></p>
<p>And answered by Andrew Gierth 
(<a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>Your first question in this scenario is, do you need to know which
subnet the packet came from? I'm not at all sure that this can be
reliably determined in all cases.</p>
<p>If you don't really care, then all you need is one socket bound to
<code>INADDR_ANY</code>. That simplifies things greatly.</p>
<p>If you <em>do</em> care, then you have to bind multiple sockets. You are
obviously attempting to do this in your code as posted, so I'll
assume you do.</p>
<p>
</p><blockquote>
<em>I was hoping that something like the following would work. Will it?
This is on Sparcs running Solaris 2.4/2.5.</em>
</blockquote>
<p></p>
<p>I don't have access to Solaris, but I'll comment based on my experience
with other Unixes.</p>
<p>[Shankar's original code omitted]</p>
<p>What you are doing is attempting to bind all the current hosts unicast
addresses as listed in hosts/NIS/DNS. This may or may not reflect
reality, but much more importantly, neglects the broadcast addresses.
It seems to be the case in the majority of implementations that a socket
bound to a unicast address will <em>not</em> see incoming packets with broadcast
addresses as their destinations.</p>
<p>The approach I've taken is to use <code>SIOCGIFCONF</code> to retrieve the list of
active network interfaces, and <code>SIOCGIFFLAGS</code> and <code>SIOCGIFBRDADDR</code>
to identify broadcastable interfaces and get the broadcast addresses.
Then I bind to each unicast address, each broadcast address, <em>and to</em>
<code>INADDR_ANY</code> <em>as well</em>. That last is necessary to catch packets 
that are
on the wire with <code>INADDR_BROADCAST</code> in the destination. 
(<code>SO_REUSEADDR</code> is
necessary to bind <code>INADDR_ANY</code> as well as the specific addresses.)</p>
<p>This gives me very nearly what I want. The wrinkles are:</p>
<p>
</p><ul>
<li>I don't assume that getting a packet through a particular socket
necessarily means that it actually arrived on that interface.</li>
<li>I can't tell anything about which subnet a packet originated on 
if its destination was INADDR_BROADCAST.</li>
<li>On some stacks, apparently only those with multicast support, I
get duplicate incoming messages on the INADDR_ANY socket.</li>
</ul><p>
</p><p>
<a name="faq52"><b>13. How can I read only one character at a time?</b></a></p><p><a name="faq52">
This question is usually asked by people who are testing their
server with telnet, and want it to process their keystrokes one
character at a time.  Without special direction from the server telnet will buffer each line of text that you type, so when you press a key, telnet won't send it until you press enter.  The correct way to read a single character is (as you would expect):
</a></p><p><a name="faq52">
<tt>read(s,buf,1)</tt> or <tt>recv(s,buf,1,flags)</tt>
</a></p><p><a name="faq52">
The rest of this answer assumes that you want to force telnet to send individual characters and not do line buffering.
</a></p><p><a name="faq52">According to Roger Espel Llima
(</a><a href="https://web.archive.org/web/20090418145854/mailto:espel@drakkar.ens.fr">espel@drakkar.ens.fr</a>), you can have
your server send a sequence of control characters: <code>0xff 0xfb 0x01 0xff 0xfb 0x03 0xff 0xfd 0x0f3</code>, which
translates to <code>IAC WILL ECHO IAC WILL SUPPRESS-GO-AHEAD IAC DO
SUPPRESS-GO-AHEAD</code>.  For more information on what this
means, check out std8, std28 and std29.  Roger also gave the
following tips:
</p><ul>
<li>This code will suppress echo, so you'll have to send the
characters the user types back to the client if you want the
user to see them.</li>
<li>Carriage returns will be followed by a null character, so
you'll have to expect them.</li>
<li>If you get a <code>0xff</code>, it will be followed by two more characters.
These are telnet escapes.</li>
</ul>
<p></p>
<p>
Thanks to Cyrus Patel (<a href="https://web.archive.org/web/20090418145854/mailto:cyp@fb14.uni-mainz.de">cyp@fb14.uni-mainz.de</a>) for emailing me some pointers on clarifying this answer.</p><p>
</p><p>
<a name="faq53"><b>14. I'm trying to exec() a program from my server, and attach my socket's IO to it, but I'm not getting all the data across.  Why?</b></a></p><p><a name="faq53">

If the program you are running uses <code>printf()</code>, etc (streams from 
<code>stdio.h</code>) you have to deal with two buffers.  The kernel buffers all 
socket IO, and this is explained in 
</a><a data-savepage-href="detail.php3?id=17" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=17">section 2.11</a>.
The second buffer is the one that is causing you grief.  This is the 
stdio buffer, and the problem was well explained by Andrew:</p>
<p>(The short answer to this question is that you want to use a pty
rather than a socket; the remainder of this article is an attempt
to explain why.)</p>
<p>Firstly, the socket buffer controlled by <code>setsockopt()</code> has <em>absolutly
nothing</em> to do with stdio buffering. Setting it to 1 is guaranteed to
be the Wrong Thing(tm).</p>
<p>Perhaps the following diagram might make things a little clearer:</p>
<p>
</p><blockquote><code>
<pre>        Process A                   Process B
    +---------------------+     +---------------------+
    |                     |     |                     |
    |    mainline code    |     |    mainline code    |
    |         |           |     |         ^           |
    |         v           |     |         |           |
    |      fputc()        |     |      fgetc()        |
    |         |           |     |         ^           |
    |         v           |     |         |           |
    |    +-----------+    |     |    +-----------+    |
    |    | stdio     |    |     |    | stdio     |    |
    |    | buffer    |    |     |    | buffer    |    |
    |    +-----------+    |     |    +-----------+    |
    |         |           |     |         ^           |
    |         |           |     |         |           |
    |      write()        |     |       read()        |
    |         |           |     |         |           |
    +-------- | ----------+     +-------- | ----------+
              |                           |                  User space
  ------------|-------------------------- | ---------------------------
              |                           |                Kernel space
              v                           |
         +-----------+               +-----------+
         | socket    |               | socket    |
         | buffer    |               | buffer    |
         +-----------+               +-----------+
              |                           ^
              v                           |
      (AF- and protocol-          (AF- and protocol-
       dependent code)             dependent code)
</pre>
</code></blockquote>
<p></p>
<p>Assuming these two processes are communicating with each other (I've
deliberately omitted the actual comms mechanisms, which aren't really
relevent), you can see that data written by process A to its stdio
buffer is completely inaccessible to process B. Only once the decision
is made to flush that buffer to the kernel (via <code>write()</code>) can the data
actually be delivered to the other process.</p>
<p>The only guaranteed way to affect the buffering within process A is to
change the code. However, the default buffering for stdout is controlled
by whether the underlying FD refers to a terminal or not; generally,
output to terminals is line-buffered, and output to non-terminals
(including but not limited to files, pipes, sockets, non-tty devices,
etc.) is fully buffered. So the desired effect can usually be achieved
by using a pty device; this, for example, is what the 'expect' program
does.</p>
<p>Since the stdio buffer (and the <code>FILE</code> structure, and everything else
related to stdio) is user-level data, it is not preserved across an
<code>exec()</code> call, hence trying to use <code>setvbuf()</code> before the exec is
ineffective.</p>
<p>A couple of alternate solutions were proposed by Roger Espel Llima
(<a href="https://web.archive.org/web/20090418145854/mailto:espel@drakkar.ens.fr">espel@drakkar.ens.fr</a>):</p>
<p>If it's an option,
you can use some standalone program that will just run something inside
a pty and buffer its input/output.  I've seen a package by the name
pty.tar.gz that did that; you could search around for it with archie or
AltaVista.</p>
<p>Another option (<em>**warning, evil hack**</em>) , if you're on a system that
supports this (SunOS, Solaris, Linux ELF do; I don't know about others)
is to, on your main program, <code>putenv()</code> the name of a shared executable
(*.so)  in LD_PRELOAD, and then in that .so redefine some commonly used
libc function that the program you're exec'ing is known to use early.
There you can 'get control' on the running program, and the first time
you get it, do a <code>setbuf(stdout, NULL)</code> on the program's behalf, and then
call the original libc function with a <code>dlopen()</code> + <code>dlsym()</code>.  And 
you keep the <code>dlsym()</code> value on a static var, so you can just call 
that the following times.</p>
<p><em>(Editors note:  I still haven't done an expample for how to do pty's, 
but I hope I will be able to do one after I finish the non-blocking 
example code.)</em></p><p>
</p><p>
</p><h3>5. Writing UDP/SOCK_DGRAM applications</h3>
<a name="faq54"><b>1. When should I use UDP instead of TCP?</b><p>


UDP is good for sending messages from one system to another when the order
isn't important and you don't need all of the messages to get to the other
machine.  This is why I've only used UDP once to write the example code
for the faq.  Usually TCP is a better solution.  It saves you having to 
write code to ensure that messages make it to the desired destination, or 
to ensure the message ordering.  Keep in mind that every additional line 
of code you add to your project in another line that could contain a 
potentially expensive bug.</p>
<p>If you find that TCP is too slow for your needs you may be able to get 
better performance with UDP so long as you are willing to sacrifice 
message order and/or reliability.</p>
</a><p><a name="faq54">
</a><a href="https://web.archive.org/web/20090418145854/mailto:ph.jounin@computer.org">Philippe Jounin <ph.jounin@computer.org></ph.jounin@computer.org></a> would like to add...</p>
<p>
</p><blockquote>
In chapter 5.1 you say UDP allows more throughput than TCP. 
It is rarely the case if you have to pass several routers.
<p>For instance, if you connect two LANs via X25 (a common way
in Europe!), every UDP datagram will :
</p><ul>
<li>establish a Virtual Channel (VC)</li>
<li>send the data</li>
<li>close the VC,</li>
</ul>

whereas the VC remains during a TCP dialog.<p></p>
</blockquote>
<p></p>
<p>UDP must be used to multicast messages to more than one other machine at 
the same time.  With TCP an application would have to open separate 
connections to each of the destination machines and send the message once 
to each target machine.  This limits your application to only communicate 
with machines that it already knows about.</p><p>
</p><p>
<a name="faq55"><b>2. What is the difference between "connected" and "unconnected" sockets?</b></a></p><p><a name="faq55">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>If a UDP socket is unconnected, which is the normal state after a
<code>bind()</code> call, then <code>send()</code> or <code>write()</code> are not allowed, since
no destination address is available; only <code>sendto()</code> can be used to
send data. </p>
<p>Calling <code>connect()</code> on the socket simply records the specified address
and port number as being the desired communications partner. That means
that <code>send()</code> or <code>write()</code> are now allowed; they use the destination
address and port given on the connect call as the destination of the
packet.</p><p>
</p><p>
<a name="faq56"><b>3. Does doing a connect() call affect the receive behaviour of the socket?</b></a></p><p><a name="faq56">
From Richard Stevens 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:rstevens@noao.edu">rstevens@noao.edu</a>):</p>
<p>Yes, in two ways.  First, only datagrams from your "connected peer"
are returned.  All others arriving at your port are not delivered to
you.</p>
<p>But most importantly, a UDP socket must be connected to receive ICMP
errors.  Pp. 748-749 of "TCP/IP Illustrated, Volume 2" give all the
gory details on why this is so.</p><p>
</p><p>
<a name="faq57"><b>4. How can I read ICMP errors from "connected" UDP sockets?</b></a></p><p><a name="faq57">

If the target machine discards the message because there is no process 
reading on the requested port number, it sends an ICMP message to your 
machine which will cause the next system call on the socket to return 
<code>ECONNREFUSED</code>.  Since delivery of ICMP messages is not guarenteed you 
may not recieve this notification on the first transaction.</a></p><a name="faq57">
<p>Remember that your socket must be "connected" in order to receive the 
ICMP errors.  I've been told, and Alan Cox has verified that Linux will 
return them on "unconnected" 
sockets.  This may cause porting problems if 
your application isn't ready for it, so Alan tells me they've added a 
<code>SO_BSDCOMPAT</code> flag which can be set for Linux kernels after 2.0.0.</p>

<p>
</p></a><p><a name="faq57">
</a><a name="faq58"><b>5. How can I be sure that a UDP message is received?</b></a></p><p><a name="faq58">


You have to design your protocol to expect a confirmation back from the 
destination when a message is received.  Of course is the confirmation is 
sent by UDP, then it too is unreliable and may not make it back to the 
sender.  If the sender does not get confirmation back by a certain time, 
it will have to re-transmit the message, maybe more than once.  Now the 
receiver has a problem because it may have already received the message, 
so some way of dropping duplicates is required.  Most protocols use a 
message numbering scheme so that the receiver can tell that it has 
already processed this message and return another confirmation.  
Confirmations will also have to reference the message number so that the 
sender can tell which message is being confirmed.  Confused?  That's why 
I stick with TCP.</a></p><p><a name="faq58">
</a></p><p><a name="faq58">
</a><a name="faq59"><b>6. How can I be sure that UDP messages are received in order?</b></a></p><p><a name="faq59">

You can't.  What you can do is make sure that messages are processed in 
order by using a numbering system as mentioned in 
</a><a data-savepage-href="detail.php3?id=58" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=58">5.5 How can I be sure that a UDP message is received?</a>.  If you 
need your messages to be received and be received in order you should 
really consider switching to TCP.  It is unlikely that you will be able 
to do a better job implementing this sort of protocol than the TCP people 
already have, without a significant investment of time.</p><p>
</p><p>
<a name="faq60"><b>7. How often should I re-transmit un-acknowleged messages?</b></a></p><p><a name="faq60">

The simplest thing to do is simply pick a fairly small delay such as one 
second and stick with it.  The problem is that this can congest your 
network with useless traffic if there is a problem on the lan or on the 
other machine, and this added traffic may only serve to make the problem 
worse.</a></p><a name="faq60">
</a><p><a name="faq60">A better technique, described with source code in "UNIX Network
Programming" by Richard Stevens (see 
</a><a data-savepage-href="detail.php3?id=6" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=6">1.6 Where can I get source code for the book [book title]?</a>), is to use an 
adaptive timeout with an exponential backoff.  This technique keeps 
statistical information on the time it is taking messages to reach a host 
and adjusts timeout values accordingly.  It also doubles the timeout each 
time it is reached as to not flood the network with useless datagrams.  
Richard has been kind enough to post the source code for the book on the 
web.  Check out his home page at
<a href="https://web.archive.org/web/20090418145854/http://www.kohala.com/~rstevens">http://www.kohala.com/~rstevens</a>.</p>


<p>
</p><p>
<a name="faq61"><b>8. How come only the first part of my datagram is getting through?</b></a></p><p><a name="faq61">

This has to do with the maximum size of a datagram on the two machines 
involved.  This depends on the sytems involved, and the MTU (Maximum 
Transmission Unit).  According to "UNIX Network Programming", all TCP/IP 
implementations must support a minimum IP datagram size of 576 bytes, 
regardless of the MTU.  Assuming a 20 byte IP header and 8 byte UDP header, 
this leaves 548 
bytes as a safe maximum size for UDP messages.  The maximum size is 65516 
bytes.  Some platforms support IP fragmentation which will allow 
datagrams to be broken up (because of MTU values) and then re-assembled 
on the other end, but not all implementations support this.</a></p><a name="faq61">
</a><p><a name="faq61">This information is taken from my reading of "UNIX Netowrk Programming" 
(see 
</a><a data-savepage-href="detail.php3?id=6" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/detail.php3?id=6">1.6 Where can I get source code for the book [book  title]?</a>).</p>
<p>Andrew has pointed out the following regarding large UDP messages:</p>
<p>Another issue is fragmentation. If a datagram is sent which is too large
for the network interface it is sent through, then the sending host will
fragment it into smaller packets which are reassembled by the receiving
host. Also, if there are intervening routers, then they may <em>also</em> need
to fragment the packet(s), which greatly increases the chances of losing
one or more fragments (which causes the entire datagram to be dropped).
Thus, large UDP datagrams should be avoided for applications that are
likely to operate over routed nets or the Internet proper.</p><p>
</p><p>
<a name="faq62"><b>9. Why does the socket's buffer fill up sooner than expected?</b></a></p><p><a name="faq62">
From Paul W. Nelson 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:nelson@thursby.com">nelson@thursby.com</a>):</p>
<p>In the traditional BSD socket implementation, sockets that are atomic
such as UDP keep received data in lists of mbufs.  An mbuf is a fixed
size buffer that is shared by various protocol stacks.  When you set
your receive buffer size, the protocol stack keeps track of how many
bytes of mbuf space are on the receive buffer, not the number of
actual bytes.  This approach is used because the resource you are
controlling is really how many mbufs are used, not how many bytes are
being held in the socket buffer.  (A socket buffer isn't really a
buffer in the traditional sense, but a list of mbufs).</p>
<p>For example:  Lets assume your UNIX has a small mbuf size of 256 bytes.
If your receive socket buffer is set to 4096, you can fit 16 mbufs
on the socket buffer.  If you receive 16 UDP packets that are 10 bytes
each, your socket buffer is full, and you have 160 bytes of data.
If you receive 16 UDP packets that are 200 bytes each, your socket
buffer is also full, but contains 3200 bytes of data.  <code>FIONREAD</code>
returns the total number of bytes, not the number of messages or bytes
of mbufs.  Because of this, it is not a good indicator of how full
your receive buffer is.</p>
<p>Additionaly, if you receive UDP messages that are 260 bytes, you use
up two mbufs, and can only recieve 8 packets before your socket buffer
is full. In this case, only 2080 bytes of the 4096 are held in the
socket buffer.</p>
<p>This example is greatly simplified, and the real socket buffer
algorithm also takes into account some other parameters.  Note that some
older socket implementations use a 128 byte mbuf.</p><p>
</p><p>
</p><h3>6. Advanced Socket Programming</h3>
<a name="faq63"><b>1. How would I put my socket in non-blocking mode?</b></a><p><a name="faq63">
From Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>):</p>
<p>Technically, <code>fcntl(soc, F_SETFL, O_NONBLOCK)</code> is incorrect since it
clobbers all other file flags. Generally one gets away with it since
the other flags (<code>O_APPEND</code> for example) don't really apply much to
sockets. In a similarly rough vein, you would use <code>fcntl(soc, F_SETFL, 0)</code>
to go back to blocking mode.</p>
<p>To do it right, use <code>F_GETFL</code> to get the current flags, set or clear the
<code>O_NONBLOCK</code> flag, then use <code>F_SETFL</code> to set the flags.</p>
<p>And yes, the flag can be changed either way at will.</p><p>
</p><p>
<a name="faq64"><b>2. How can I put a timeout on connect()?</b></a></p><p><a name="faq64">
Andrew Gierth 
(</a><a href="https://web.archive.org/web/20090418145854/mailto:andrew@erlenstar.demon.co.uk">andrew@erlenstar.demon.co.uk</a>) has outlined the following
procedure for using <code>select()</code> with <code>connect()</code>, which will allow you to
put a timeout on the <code>connect()</code> call:</p>
<p>First, create the socket and put it into non-blocking mode, then call
<code>connect()</code>. There are three possibilities:</p>
<p>
</p><ul>
<li>connect succeeds: the connection has been successfully made (this
usually only happens when connecting to the same machine)
</li>
<li>connect fails: obvious
</li>
<li>connect returns -1/<code>EINPROGRESS</code>. The connection attempt has begun,
but not yet completed.</li>
</ul>
<p></p>
<p>If the connection succeeds:</p>
<p>
</p><ul>
<li>the socket will <code>select()</code> as writable (and will 
also select as readable
if data arrives)</li>
</ul>
<p></p>
<p>If the connection fails:</p>
<p>
</p><ul>
<li>the socket will select as readable *and* writable, but either a read
or write will return the error code from the connection attempt. Also,
you can use <code>getsockopt(SO_ERROR)</code> to get the error status - but be
careful; some systems return the error code in the result parameter of
<code>getsockopt()</code>, but others (incorrectly) cause the <code>getsockopt</code>
call <em>itself</em>
to fail with the stored value as the error.</li>
</ul>
<p></p>
<p>Sample code that illustrates this can be found in 
the file <code><a data-savepage-href="connect.c" href="https://web.archive.org/web/20090418145854/http://www.sbin.org/doc/unix-faq/connect.c"><http: www.developerweb.net="" sock-faq="" connect.c=""></http:></a></code>.</p><p>
</p><p>
<a name="faq66"><b>3. How do I complete a read if I've only read the first part of something, without again calling select()?</b></a></p><p><a name="faq66">
<i>Not yet answered</i></a></p><p><a name="faq66">
</a><a name="faq69"><b>4. How to use select routine</b></a></p><p><a name="faq69">
<i>Not yet answered</i></a></p><p><a name="faq69">
</a><a name="faq72"><b>5. RAW sockets</b></a></p><p><a name="faq72">
<i>Not yet answered</i></a></p><p><a name="faq72">
</a><a name="faq76"><b>6. Restricting a socket to a given interface</b></a></p><p><a name="faq76">
<i>Not yet answered</i></a></p><p><a name="faq76">
</a><a name="faq89"><b>7. Receiving all incoming traffic through a RAW-socket?</b></a></p><p><a name="faq89">
<i>Not yet answered</i></a></p><p><a name="faq89">
</a><a name="faq91"><b>8. Multicasting</b></a></p><p><a name="faq91">
<i>Not yet answered</i></a></p><p><a name="faq91">
</a><a name="faq108"><b>9. getting IP header of a UDP message</b></a></p><p><a name="faq108">
<i>Not yet answered</i></a></p><p><a name="faq108">
</a><a name="faq120"><b>10. To fork or not to fork?</b></a></p><p><a name="faq120">
<i>Not yet answered</i></a></p><p><a name="faq120">
</a></p><h3><a name="faq120">7. Sample Source Code</a></h3><a name="faq120">
</a><a name="faq73"><b>1. Looking for a good C++ socket library</b><p>
<i>Not yet answered</i></p></a><p><a name="faq73">
</a><a name="faq79"><b>2. perl examples of source code</b></a></p><p><a name="faq79">
<i>Not yet answered</i></a></p><p><a name="faq79">
</a><a name="faq102"><b>3. Where is the source code from Richard Stevens' books?</b></a></p><p><a name="faq102">
<i>Not yet answered</i></a></p><p><a name="faq102">
</a></p><h3><a name="faq102">8. Bugs and Strange Behaviour</a></h3><a name="faq102">
</a><a name="faq77"><b>1. send() hangs up when sending to a switched off computer</b><p>
<i>Not yet answered</i></p></a><p><a name="faq77">
</a><a name="faq80"><b>2. Error when using inetd</b></a></p><p><a name="faq80">
<i>Not yet answered</i></a></p><p><a name="faq80">


</a></p><p><a name="faq80">
</a></p><hr><a name="faq80">
<font size="-2">
Contents are Copyright© by the author of the content.  Permission is granted
to do anything you like with this contents so long as you don't claim the
work, or copyright for yourself.  The </font></a><font size="-2"><a href="https://web.archive.org/web/20090418145854/http://www.developerweb.net/ssfaq/">Self
Serve FAQ</a> is Copyright© by it's authors, and available under the
terms of the GNU GPL.
</font>

</b></body></html>